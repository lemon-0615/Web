# 1. 概述

## 1.1 对VUE的理解（认识）

- 首先从利于前端工程化的角度去考虑使用前端框架，可以提高开发效率和开发质量。vue可以通过vue-cli快速初始化项目，做到开箱即用，轻量便捷。
- 而Vue具有响应式编程、组件化两大特点，通过MVVM模式实现**双向数据绑定**，**组件化**可以减少代码复用。
- 同时Vue利用**路由机制**实现单页面应用，页面局部刷新，不需要每次切换路由都向后端发起请求。
- 并且可以通过**Vuex集中式存储**管理应用的所有组件的状态，为复杂组件间的通信提供解决方案。

## 1.2 渐进式框架

渐进式框架（自底向上增量开发的设计）。我的理解是：渐进式框架主张最少，没有多做职责之外的事。

- 每个框架都有各自的特点，会对开发者有一定的要求，比如Angular就是强主张型的，如果要用它就必须使用它的（模板机制、依赖注入等），React的主张程度相对弱一些，它是具有函数式编程的理念，需要调用api去修改数据。
- 而对于Vue来说并没有强主张，开发者需要什么就去做什么，不是说强制一定要使用一些全家桶之类的，可以"按需使用"。

## 1.3 vue-cli脚手架理解

> **脚手架：**实现工程的初始化。为了让开发者能够**开箱即用**快速地进行应用开发。

基本配置都配置好了，开发者只要专注于业务开发即可。举例：造房时先搭个架子（脚手架），然后慢慢往里面砌砖，直到建筑成型。

1. vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。
2. vue-router：vue官方推荐使用的路由框架。
3. vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。
4. axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。
5. vux等：一个专为vue设计的移动端UI组件库。
6. 创建一个emit.js文件，用于vue事件机制的管理。
7. webpack：模块加载和vue-cli工程打包器。

## 1.4 单页面和多页面

**多页应用：**（页面跳转  => 返回HTML）每次切换url跳转页面时，都会向后端发出http请求，由后端返回一个新的html页面。

- **优点：**首屏时间快，seo效果好
- **缺点：**页面切换慢

**单页应用：**（页面跳转  => JS渲染）通常在仅在第一次进入页面时会向后请求一个html文件，和所有必需的CSS、JS代码，之后所有的活动都局限在该页面。因为用户操作改变页面时，它不会向后端请求一个新的html，而是利用JS动态地变换HTML里的元素，渲染出一个新页面。

- **优点：**页面切换快
- **缺点：**首屏事件稍慢，seo效果差

### SPA缺点和解决方法

1. **对SEO不是很友好。**因为搜索引擎是根据网页内容设置网页权重，来进行网页的排名。它只认识html内容，不认识js内容，而SPA的内容都是靠js渲染生成出来的。

- **解决方法：**预渲染，SSR

  如果只是想改善少数静态营销页面的SEO，只需要使用较简单的预渲染。

2. **首屏加载慢。**初始加载时候由于加载所有模块文件进行渲染，首屏时间会慢一点。

- **解决方法：**骨架图，loadding效果，SSR

3. 页面发生变化后，也无法利用浏览器工具栏上的倒退、前进按钮进行操作。

- **解决方法：**配置好路由信息，通过记录浏览过的历史路由信息，可以很好的记录或历史查看过的界面，也可以独立写个足迹功能实现。

## 1.5 CSR和SSR

### 1.5.1 CSR（客户端渲染）

服务端把渲染的静态文件发给客户端，客户端跑了脚本后生成相应DOM，然后渲染给用户。数据注入部分是客服端做的。

- **好处：** 网络传输数据量小、减少了服务器压力、前后端分离、局部刷新，无需每次请求完整页面、交互好可实现各种效果
- **坏处：**不利于SEO、爬虫看不到完整的程序源码、首屏渲染慢（渲染前需要下载一堆js和css等）

### 1.5.2 SSR（服务端渲染）

服务端把需要的组件或页面渲染成 HTML 字符串，再发给客户端，客户端只负责解析 HTML ，不需要去解析编译js操作DOM。

- **好处：首屏渲染快、利于SEO**、可以生成缓存片段，生成静态化文件、节能（对比客户端渲染的耗电）
- **坏处：**用户体验较差、不容易维护，通常前端改了部分html或者css，后端也需要修改。

# 2. VUE

- **vue两大特点：**响应式编程、组件化。
- **vue的优势：**轻量级框架、简单易学、双向数据绑定、组件化、数据和结构的分离、虚拟DOM、运行速度快。
- **vue是单页面应用**，使页面局部刷新，不用每次跳转页面都要请求所有数据和dom，这样大大加快了访问速度和提升用户体验。而且他的第三方ui库很多节省开发时间。

## 2.2 vue属性

**以下三者的区别：**methods->computed->watch逐步响应式。methods每次调用每次执行；computed有缓存机制，只要对应data中数据没变，多次调用只执行一次；watch只要数据改变就会自动执行回调。

### methods

> methods是**函数调用**，没有缓存功能。

### computed

> computed是**属性调用**，具有**缓存功能**。

computed依赖于data中的数据，只有在它的相关依赖数据发生改变时才会重新求值。

- computed其实是既可以当做**属性**访问也可以当做**方法**访问
- computed的由来还有一个重要原因，就是**防止文本插值中逻辑过重**，导致不易维护

### watch

> watcher 是 data中每个数据的监听回调，当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。

Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。

从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据。

[浅析Vue中computed与method的区别]: https://segmentfault.com/a/1190000014478664

### data

- **为什么是函数不是对象？**

  重复创建（vue组件）实例会造成多实例共享一个数据对象，A组件修改data，B组件中的data也会相应改变。所以通过`return object`的方式给每个实例返回自己的数据域。

- **为什么this.a就能取到数据？而不用this.$data.a？**

  this.$data是是所有组件共享的数据，而this.a是组件内独有的数据

## 2.3 vue指令（v-）

|           特性            | 描述                                                        |
| :-----------------------: | ----------------------------------------------------------- |
|          v-bind           | 对属性进行绑定（:），如，:style驼峰式分词，:class样式隐藏否 |
|           v-on            | 绑定事件（@）                                               |
|          v-model          | 表单数据的双向绑定                                          |
|           v-for           | 循环                                                        |
| v-if / v-else-if / v-else | 控制标签元素（每次都会删除或创建元素，会引起回流）          |
|          v-show           | 控制标签元素（本质就是通过设置标签属性display为none）       |
|          v-text           | 直接进行输出                                                |
|          v-html           | 把数据解析成html代码执行                                    |
|          v-slot           |                                                             |
|           v-pre           |                                                             |
|          v-cloak          |                                                             |
|          v-once           |                                                             |

### v-if和v-show的区别

**v-show：**本质就是通过设置标签属性display为none，来控制隐藏；只编译一次，后面的每次渲染其实就是控制css，开销较小；适用于频繁切换的场景

**v-if：**本质是动态的向DOM树内添加或者删除DOM元素；根据值的真假不停的销毁和创建DOM，开销较大；适合于不频繁切换页面元素的场景

### v-for和v-if不能同时使用

`v-for比v-if`优先级高，如果同时使用的的话，每次`v-for`都会执行`v-if`，如果需要遍历很大的一个数组，只有一个需要`v-if`渲染，这样会导致一些不必要的计算，浪费性能，所以一般在computed中先对数组进行过滤再使用。

## 2.4 对比React/Angular区别

|  框架   | 描述                                                         |
| :-----: | ------------------------------------------------------------ |
| JQuery  | 更方便的选取和操作DOM对象、数据和界面是在一起的。            |
|   Vue   | 更注重web开发者的习惯，用HTML渲染模板；声明式编程（直接赋值）；push-based；v-model双向数据流；vuex使用的是可变的数据；vue-cli |
|  React  | 用JSX渲染模板；函数式编程（需要调用api去修改数据）；pull-based；单向数据流；redux使用的是不可变的数据；Create React App (CRA)；需要对虚拟DOM渲染出来的结果做脏检查 |
| Angular | 声明式编程；脏检查，所以watcher越多越慢                      |

### 1）React

**不同点：**

- React采用Virtual DOM会对渲染出来的结果做脏检查；
- **数据管理：**Vuex管理可变数据，直接修改；Redux管理不可变数据，新替旧
- **代码风格：**react推荐jsx，把html，css都写进js里面，all in js；vue推荐webpack+vue-loader的单文件组件格式，html，css，js都写在.vue里面。
- React不使用模板，它要求开发者借助JSX在JavaScript中创建DOM。函数式编程，是类式写法，api很少；vue用模板搭建项目。使用声明式写法，传入各种options,api和参数都很多，但vue3.0支持类式写法。

**相同点：**

- React采用独特的JSX语法，Vue.js 在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定；
- 两者都需要编译后使用；
- 中心实现相同：一切都是组件，组件实例之间可以嵌套；
- 都提供合理的钩子函数，可以让开发者定制化地处理需求，都不内置列数Ajax，Route等功能到核心包，而是以插件的方式加载；
- 在组件开发中都支持mixins的特性了。

### 2）AngularJs

**相同点：**都支持指令，内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定，都不支持低端浏览器；

**不同点：**AngularJs的学习成本高，比如Dependency、Injecttion特性，而vue.js本身提供的API都比较简单、直观；在性能上，AngularJs依赖对数据做脏检查，所以watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所以的数据都是独立触发的。

### 3）Jquery

Vue直接操作视图层，它通过Vue对象将数据和View完全分离开来了。对数据进行操作不需要引用相应的DOM节点，只需要关注逻辑，完全实现了视图层和逻辑层的解耦；

Jquery的操作是基于DOM节点的操作，jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的js的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。它的优势在于良好的封装和兼容，使调用简单方便。

# 3. VUE生命周期

Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，我们可以很好的在 Vue 的各个生命阶段实现一些操作。

- 生命周期函数 = 生命周期钩子 = 生命周期事件
- https://cn.vuejs.org/images/lifecycle.png

## 3.1 生命周期具体过程

```vue
var vm = new Vue() // 表示开始创建一个Vue实例
```

初始化了一个Vue空的实例对象，此时该对象只有一些默认的生命周期函数和默认的事件，其他的都未创建。

- `beforeCreate`：data和methods中的数据都还没有被初始化。
- `created`：data和methods都已经被初始化好了
- `beforeMount`：模板在内存中编辑完成，但是没有渲染到页面中。（开始编译模板，执行Vue代码中的指令，在内存中生成一个编译好的模板字符串）
- `mounted`：内存中的模板，已经挂载到页面中，用户可以看到。
- `beforeUpdate`：此时data数据是最新的，页面尚末和最新的数据保持同步。

根据data中最新的数据，在内存中重新构建虚拟DOM（渲染树），然后再渲染到页面中去（回流），完成了数据从data(Model)->View

- `updated`：页面和data数据已经保持同步了，都是最新的。
- `beforeDestroy`：实例身上所有的data、methods、过滤器、指令...都处于可用状态，此时，还没有真正执行销毁过程。
- `destroy`：组件已经完全被销毁了，此时组件中所有的data、methods、过滤器、指令...都已经被销毁了。

**keep-alive相关的生命周期钩子函数：**

- activated： 进入页面时触发。（常用来实现每次进入页面的时候重新获取最新的数据）
- deactivated：退出页面时触发。

```js
<body>
    <div>
        <input type="button" values"修改msg" @click="msg='No"">
        <h3 id="h3">{{ msg }}</h3>
    </div>
	<script>
        var vm = new Vue({
            el: '#app',
            data: {
                msg: "Ok"
            },
            methods: {
                show() {
                    console.log("执行了show方法")
                }
            },
            // 实例创建阶段
            beforeCreate () {  // 这是我们遇到的第1个生命周期函数,表示实例完全被创建出来之前,会执行它。
                console.log (this.msg)
                this.show()
                // 注意:在beforecreate生命周期函数执行的时候, data和methods中的数据都还没有被初始化。
            } 
            created () {	// 这是遇到的第2个生命周期函数。
                console.log (this.msg)
                this.show()
                // 在created中, data和methods都已经被初始化好了，如果要调用methods中的方法,或者操作data中的数据，最早只能在created中操作。
            }
			// 	模板编译：这里表示Vue开始编译模板，执行Vue代码中的那些指令。最终，在内存中生成一个编译好的模板字符串，渲染为内存中的DOM。此时，只是在内存中渲染好了模板，并没有把模板挂载到真正的页面中去。
            beforeMount () // 这是遇到的第3个生命周期函致，表示模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中。
                console.log(document.getElementBytd('h3').innerText)
                // 在beforeMount执行的时候,页面中的元素,还没有被真正替换过来,只是之前写的一些模板字符串。
            }
            mounted () {	// 这是遇到的第4个生命周期函数,表示内存中的模板,已经真实的挂载到了页面中,用户已经可以看到挂载好的页面了。
                console.log(document.getElementBytd('h3').innerText)
                // 注意: mounted是实例创建期间的最后一个生命周期函数,当执行完mounted就表示,实例已经被完全创建好了,此时,如果没有其他操作的话,这个实例,就静静的躺在我们的内存中,一动不动。
                // 如果要通过某插件操作页面上的DOM节点，最早要在mounted中进行。
            }
            // 运行阶段：会根据data数据的改变，有选择性地触发0到多次
            beforeUpdate () {	// 这时候,表示我们的界面还没有被更新，但是数据已经被更新了
				console.log("界面上元R的内容：" + document.getElementBytd('h3').innerText)
                console.1og ("data中的msg数据是:" + this.msg)
                // 得出结论: 当执行beforeUpdate的时候,页面中的显示的数据,还是旧的,此时data数据是最新的,页面尚末和最新的数据保持同步
            }
			// 根据data中最新的数据，在内存中重新构建虚拟DOM（渲染树），然后再渲染到页面中去（回流），完成了数据从data(Model)->View。
            updated () {
				console.log("界面上元R的内容：" + document.getElementBytd('h3').innerText)
                console.1og ("data中的msg数据是:" + this.msg)
				// updated事件执行的时候,页面和data数据已经保持同步了,都是最新的
            }
            // 销毁阶段：页面关闭等操作
			beforeDestroy () {
				// 当执行beforeDestroy的时候，实例身上所有的data、methods、过滤器、指令...都处于可用状态，此时，还没有真正执行销毁过程。
            }
			destroy () {
                // 当执行destroy的时候，组件已经完全被销毁了，此时组件中所有的data、methods、过滤器、指令...都已经被销毁了。
            }
	</script>
</body>
```

- `$el`：用来挂载当前组件实例的`dom`元素
- `$els`：用来访问`$el`元素中使用了`v-el`指令的`DOM`元素

**initState初始化方法执行顺序：**Props -> Methods -> Data -> Computed -> Watch

## 3.2 父子组件生命周期

- **加载渲染过程（父等子mounted）**

  父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- **子组件更新过程（父等子update）**

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- **父组件更新过程**

  父 beforeUpdate -> 父 updated

- **销毁过程（父等子destroyed）**

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed

### 3.2.1 父组件监听子组件

**1、使用on和emit**

子组件emit触发一个事件，父组件emit触发一个事件，父组件on监听相应事件。

```js
// Parent.vue
<Child @mounted="doSomething"/>

// Child.vue
mounted() {
  this.$emit("mounted");
}
```

**2、hook钩子函数**

这里一种特别简单的方式，子组件不需要任何处理，只需要在父组件引用的时候通过`@hook`来监听即可，代码重写如下：

```js
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>
doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...   
```

# 4. 数据绑定

## 4.1 架构模式

### 4.1.1 MVC

- 视图（View）：用户界面；
- 控制器（Controller）：业务逻辑
- 模型（Model）：数据保存

View 把指令传给 Controller；Controller 完成业务逻辑操作后， 改变 Model状态；Model 将新的数据发送到 View，用户得到反馈。

**两种接收指令的方式：**1. 通过 View 接受指令，然后传递给 Controller；2. 直接通过controller接受指令。

**前端具体应用：**Backbone.js

<img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020105.png" alt="img" style="zoom: 60%;" />

### 4.1.2 MVP

将 Controller 改名为 Presenter，并改变了通信方向。

1. 各部分之间的通信，都是双向的。

2. View 与 Model 不发生联系，都通过 Presenter 传递。

3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。

<img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt="img" style="zoom:60%;" />

### 4.1.3 MVVM

- **Model，** 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
- **View，** 代表UI组件，它负责将数据模型转化成UI 展现出来。
- **ViewModel，** 监听模型数据的改变和控制试图行为、处理用户交互、简单理解就是一个同步View和Model的对象，连接Model和View。

**MVVM 的设计思想：**MVVM中的View通过使用模板语法来声明式的将数据渲染进DOM，当ViewModel对Model进行更新的时候，会通过数据绑定更新到View。（本质是观察者模式）

**前端具体应用：**AngularJs、EmberJs、VueJs

#### 1）MVVM缺点

- 数据绑定使得一个位置的 Bug 被快速传递到别的位置，问题的定位变得困难。可能是 View / Model 代码有问题。
- 数据双向绑定中，一个View绑定一个model，不同模块的model都不同，不利于代码重用。
- 一个模块中model很大的情况下，如果长期持有不释放内存会造成内存泄漏。

<img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020110.png" alt="img" style="zoom:60%;" />

#### 2）MVVM和MVC区别

- MVC中Controller演变成MVVM中的ViewModel
- MVVM通过数据来显示视图层，并采用数据双向绑定原理，MVC是通过Controller来进行节点的操作
- MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低，加载速度变慢，影响用户体验

#### 3）MVVM和MVP区别

MVVM采用数据双向绑定：View的变化会自动反映在 ViewModel，反之亦然。

### 4.1.4 观察者模式实现

```js
class Subject{
    constructor(){
        this.observers = []
    }
    addObserver(observer){
        this.observers.push(observer)
    }
    removeObserver(observer){
        let index = this.observers.indexOf(observer)
        if(index > -1){
            this.observers.splice(index,1)
        }
    }
    notify(){
        this.observers.forEach(observer=>{
            observer.update()
        })
    }
}
class Observer{
    constructor(name){
        this.name = name
        this.update = function(){
            console.log(name + ' update...')
        }
    }
}
let subject = new Subject()    //创建主题
let observer1 = new Observer('xiaowang')    //创建观察者1
subject.addObserver(observer1)    //主题添加观察者1
let observer2 = new Observer('xiaozhang')    //创建观察者2
subject.addObserver(observer2)    //主题添加观察者2
subject.notify()    //主题通知观察者

/**** 输出 *****/
xiaowang update...
xiaozhang update...
```

## 4.2 双向数据绑定

### 4.2.1 对象绑定原理

采用数据劫持和发布者-订阅者模式的方式，主要涉及Observer、Compile和Watcher三者。在`new Vue()`后， Vue 会调用`_init`函数进行初始化，Observer通过`Object.defineProperty()`来劫持监听属性的`getter`/`setter`，当对象被读取的时候执行`getter`函数，当数据发生变化的时候，就会触发对应的`setter`，然后通知订阅器（Dep）的`dep.notify()`找到对应的 Watcher调用`update`中的`patch()`比较新旧vdom节点，根据差异对视图进行更新渲染（有多少个data就有多少个订阅者Watcher），此时通过Compile解析编译模板指令，找到数据变更的位置，然后更新视图（节点）。

- **注意：**如果同一个 watcher 被多次触发，只会被推入到队列中一次，触发微任务nextTick。
- **Object.defineProperty()缺点**
  - 无法监听数组变化
  - 只能劫持对象的属性，监听时需要遍历属性。
- **Vue3使用proxy：**在获取目标对象之前架设一层“拦截”，可以对外界的访问进行过滤和改写。 
  - proxy可以监听对象而非属性，并返回一个新对象（proxy可以直接监听数组的变化）。
  - 除了 get 和 set，proxy有多达13种的拦截方法。速度加倍、内存减半
- **兼容性：**Proxy 对 IE 不友好，vue3 在检测到使用 IE 的情况下（包括 IE11），会自动降级为 Object.defineProperty 的数据监听系统

![img](https://segmentfault.com/img/remote/1460000020715457)

[Vue3为何使用Proxy实现数据监听]: https://juejin.im/post/6857877411913990158	"Vue3为何使用Proxy实现数据监听"

[Vue中this.$nextTick 的作用]: https://segmentfault.com/a/1190000020715185
[Vue的MVVM实现原理 / 双向数据绑定原理]: https://juejin.im/post/5edefb32518825431373704c

### 4.2.2 数组绑定原理

在将数组处理成响应式数据后，如果使用数组原始方法改变数组时，数组值会发生变化，但是并不会触发数组的setter来通知所有依赖该数组的地方进行更新。为此**vue通过重写数组的push、pop、shift（从数组前面删除）、unshift、splice、sort、reverse来监听数组变化，重写后的方法会执行`ob.dep.notify()`将当前数组的变更通知给其订阅者**，这样当使用重写后方法改变数组后，数组订阅者会将这边变化更新到页面中。

重写完数组的上述7种方法外，我们还需要将这些重写的方法应用到数组上，因此在Observer构造函数中，可以看到在监听数据时会判断数据类型是否为数组。当为数组时，

1. 如果浏览器支持`__proto__`，则直接将当前数据的原型`__proto__`指向重写后的数组方法对象arrayMethods
2. 如果浏览器不支持`__proto__`，则直接将arrayMethods上重写的方法直接定义到当前数据对象上；
3. 当数据类型为非数组时，继续递归执行数据的监听。

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\image-20200917212004121.png" alt="image-20200917212004121" style="zoom:80%;" />

[vue中是如何监听数组变化]: https://blog.csdn.net/XuM222222/article/details/99950241

### 4.2.3 发布-订阅者模式（实现）

> 对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。

1. **实现一个数据监听器Observer，**能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者Watcher

   `Obeject.defineProperty()`来监听属性变动，将需要监听的数据对象进行递归遍历，包括子属性对象的属性，都加上 `setter`和`getter` 这样的话，给这个对象的某个值赋值，就会触发`setter`，那么就能监听到了数据变化。

2. **实现一个消息订阅器Dep，**维护一个数组，用来收集订阅者Watcher，数据变动触发`Dep.notify()`，再调用订阅者的`update()`

   `var dep = new Dep();`是在 `defineReactive`方法内部定义的，所以想通过`dep`添加订阅者，就必须要在闭包内操作，所以我们可以在 `getter`里面动手脚，在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除

3. **实现一个指令解析器Compile，**对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。

4. **实现一个Watcher，**作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

   - 在自身实例化时往订阅器Dep里面添加自己
   - 自身有一个`update()`方法
   - 当属性变动`Dep.notify()`通知时，调用自身的`update()`方法，触发Compile中绑定的回调函数

5. **mvvm入口函数，整合以上三者**

![img](E:\Cloud\工作\前端之路\前端笔记\fig\1565076114(1).png)

![img](E:\Cloud\工作\前端之路\前端笔记\fig\1566885705(1).png)

```js
classPubSub {
    constructor() {
        this.subscribers = [];
    }
     
    subscribe(topic, callback) {
        let callbacks = this.subscribers[topic];
        if(!callbacks) {
            this.subscribers[topic] = [callback];
        } else{
            callbacks.push(callback);
        }
    }
     
    publish(topic, ...args) {
        letcallbacks = this.subscribers[topic] || [];
        callbacks.forEach(callback => callback(...args));
    }
}

let pubSub = newPubSub();		// 创建事件调度中心，为订阅者和发布者提供调度服务
pubSub.subscribe('SMS', console.log);// A订阅了SMS事件（A只关注SMS本身，而不关心谁发布这个事件）
// B订阅了SMS事件
pubSub.subscribe('SMS', console.log);
// C发布了SMS事件（C只关注SMS本身，不关心谁订阅了这个事件）
pubSub.publish('SMS', 'I published `SMS` event');
```

## 4.3 观察者和发布订阅模式区别

**观察者模式：**目标（Subject）和观察者之间是没有事件调度中心的，观察者需要在目标中进行统一管理，并亲自去通知所有的观察者。

**发布-订阅者模式：**相比观察者模式多了个**事件调度中心**，管理事件的订阅和发布工作，彻底隔绝了订阅者和发布者的依赖关系。

# 5. 组件通信

#### v-model

**语法糖：**会忽略所有表单元素的 `value`、`checked`、`selected` 特性的初始值而总是将 Vue 实例的数据作为数据来源，即会覆盖v-bind

```html
<input v-model="message">  <!--相当于下列代码的语法糖-->
<input :value="message" @input="message = $event.target.value" />
<p>{{ message }}</p>
```

**组件通信：**当组件中的某个 `prop` 需实现双向绑定时，使用`v-model` 就不需要自己手动在组件上绑定监听当前实例上的自定义事件。

```html
<!-- 父组件 -->
<base-input v-model="input"></base-input>

<!-- 子组件 -->
<template>
    <input type="text" :value="currentValue"  @input="handleInput">
</template>
<script>
    export default {
        data() {
            return {
                currentValue: this.value === undefined || this.value === null ? ''
            }
        },
        props: {
            value: [String, Number],
        },
        methods: {
            handleInput(event) {
                const value = event.target.value;
                this.$emit('input', value);
            },
        },
}
</script>
```

#### .sync

- vue1.x 版本中，当子组件改变了一个带有 `.sync` 的 `prop` 的值时，会将这个值同步到父组件中的值。但破坏了单向数据流。

- vue2.0 移除了 `.sync`
- 在实际的应用中，`.sync` 有具体的应用场景，所以在 vue 2.3 版本中， `.sync` 修饰符所实现的已经不再是真正的双向绑定，它的本质和 `v-model` 类似，只是一种**语法糖**。

```html
<text-document
  :title="doc.title"
  @:update:title="doc.title = $event">
</text-document>
<!-- 上面的代码，使用 .sync 就可以写成 -->
<text-document :title.sync="doc.title"></text-document>

```

这样，在子组件中，就可以通过下面代码来实现对这个 `prop` 重新赋值的意图了。

```js
this.$emit('update:title', newTitle);
```

#### v-model 和 .sync 对比

- `.sync` 更加灵活，它可以给多个 `prop` 使用，而 `v-model` 在一个组件中只能有一个。

-  从语义上来看，`v-model` 绑定的值是指这个组件的绑定值，比如 input 组件，select 组件，日期时间选择组件，颜色选择器组件，这些组件所绑定的值使用 `v-model` 比较合适。其他情况，没有这种语义，使用 `.sync` 更好。

## 5.1 父-->子  

- **props**：父组件通过标签特性传递给子组件，子组件通过props来获取
- **provide / inject**：父组件通过provider传递数据，子组件通过inject来获取
- **$attrs / $$listeners**：子组件通过v-bind绑定`$$attrs`，其中包含着不被prop识别的父组件传递过来的数据。通过v-on绑定`$listeners`将事件传递给子组件。
- **$parent**：父组件的实例对象

#### 1）props

父组件在子组件标签特性里将数据值传递给prop，子组件通过props属性定义的prop列表，从而让子组件可访问这个值。

```js
// 父：传递list
<com-article :alist="list"></com-article>
// 子
props: ['alist']
```

#### 2）provide / inject

在父组件中通过 `provider` 来提供属性，然后在子组件（子孙组件）中通过 `inject` 来注入变量。

```js
// 父：传递list
provide: {
    list: 'test'
}
// 子/子孙
inject: ['list']
```

#### 3）$attrs / $listeners

子组件中的`$attrs`包含了父组件组件中不被prop所识别的特性绑定，使用v-bind绑定 `$attrs`在孙子组件上，将数据传递给孙子组件；

子组件中的`$listeners`包含了父组件绑定在子组件上的事件，使用v-on绑定`$listeners`在孙子组件上，将事件传递给孙子组件。

```html
// 父A：传递list
<B :messagec="messagec" :message="message" @getCData="getCData" @getChildData="getChildData(message)">
methods: {
    getChildData(val) {
      console.log(`这是来自B组件的数据：${val}`);
    },
    getCData(val) {
      console.log(`这是来自C组件的数据：${val}`);
    }
}
// 子B
<!-- C组件中能直接触发 getCData 的原因在于：B组件调用 C组件时，使用 v-on 绑定了 $listeners 属性 -->
<!-- 通过v-bind 绑定 $attrs 属性，C组件可以直接获取到 A组件中传递下来的 props（除了 B组件中 props声明的） -->
<C v-bind="$attrs" v-on="$listeners"></C>
props: ['message'],
data(){
    return {
      mymessage: this.message
    }
},
methods: {
    passData(val){
      //触发父组件中的事件
      this.$emit('getChildData', val)
    }
}
// 子孙C
<input type="text" v-model="$attrs.messagec" @input="passCData($attrs.messagec)">
methods: {
    passCData(val) {
      // 触发父组件A中的事件
      this.$emit('getCData',val)
    }
}
```

#### 4）$children / $parent

`$parent` ：子传父，子组件直接调用

`$children`：父传子，父组件直接调用，返回的是一个子组件Array。

```js
// 父
this.$children[0].boymessage = 'hello';
// 子
data() {
    boymessage: this.$parent.message
}
this.$parent.message = this.boymessage;//通过如此调用可以改变父组件的值
```

## 5.2 子 -->父 

- **$emit / v-on**：将数据作为`this.$$emit`方法的参数，回传给父组件用`v-on：[自定义事件]`监听的函数。
- **ref / $refs**：父组件通过调用子组件ref名获取数据或调用方法，并且获取的是实时数据。
- **$children**：子组件的实例对象，是数组类型的，并不保证顺序，也不是响应式的。

#### 1）$emit / v-on

通过在子组件中触发一个自定义事件`this.$emit`，将数据作为`this.$emit`方法的参数，回传给父组件用`v-on：[自定义事件]`监听的函数。

```html
// 父组件
<son v-on:sendData='getSonText'></son>
<script>
import son from './son.vue'
export default {
  ...
  methods: {
    getSonText (text) {
      this.text = text
    }
  }
}
</script>
```

```html
// 子组件
<script>
export default {
  ...
  methods: {
    sendData () {
      this.$emit('sendData', this.text)
    }
  }
}
</script>
```

#### 2）ref / $refs

通过ref对子组件做标记，父组件可以通过`vm.$refs.[子组件的ref].[子组件的属性/方法]`这种方式直接取得子组件的数据、和方法，并且获取的是实时数据。

```html
// 父组件
<child ref="msg"></child>
<script>
export default {
  ...
  methods:{
    submitForm () {
      var _this = this
      _this.data = _this.$refs.msg.tableData
      //只要子组件的data中有tableData这个数据，我们就能在父组件中获取到他
      _this.flag= _this.$refs.msg.sendMsg()
      //只要子组件的methods中有sendMsg这个方法，我们就能在父组件中调用他
    }
  }
}
</script>
```

## 5.3 兄-->弟

- **子传父、父传子**
- **eventBus**：新建一个 `Vue` 对象 `bus`，挂载到Vue.prototype，然后通过 `bus.$emit` 触发事件，`bus.$on` 监听触发的事件。
- **vuex**：使用`commit`触发一个`mutation`修改store中的state数据，通过`this.$store.state.[属性名]`获取vuex仓库中的数据

分类：全局守卫，路由独享守卫，组件内守卫。

#### 1）eventBus中央事件总线

通过新建一个 `Vue` 对象 `bus`，挂载到Vue.prototype，然后通过 `bus.$emit` 触发事件，`bus.$on` 监听触发的事件。

**原理：**事件总线，是一种发布-订阅模式。注册时就将订阅者存在一个数组中，发布时就触发事件 `bus.$emit`，然后通过`.notify()`进行发布，订阅者通过``bus.$on``进行监听

相比之下，vuex会将通知的概念上升到共享状态层次，有利于后期代码的维护。

```js
// 定义中央事件总线
const EventBus = new Vue();
// 将中央事件总线赋值到 Vue.prototype 上，这样所有组件都能访问到了
Vue.prototype.$EventBus = EventBus;

// 组件A
this.$EventBus.$emit('globalEvent', val)
// 组件B  绑定全局事件globalEvent
this.$EventBus.$on('globalEvent', (val) => {
    this.brothermessage = val;   // 组件A 传递过来的数据brothermessage
});
```

#### 2）vuex

- 使用`this.$store.commit('[函数名]', {'[state属性名]': 属性值})`更新vuex仓库中的数据。
- 使用`this.$store.state.[属性名]`获取vuex仓库中的数据。
- 将state和mutations挂载到Vuex.Store实例上去

```js
// 兄弟组件A（B结构一样）
<button @click="transform">点我让B组件接收到数据</button>
<p>因为你点了B，所以我的信息发生了变化：{{BMessage}}</p>

	data() {
      return {
        AMessage: 'Hello，B组件，我是A组件'
      }
    },
    computed: {
      BMessage() {
        // 这里存储从store里获取的B组件的数据
        return this.$store.state.BMsg
      }
    },
    methods: {
      transform() {
        // 触发receiveAMsg，将A组件的数据存放到store里去
        this.$store.commit('receiveAMsg', {
          AMsg: this.AMessage
        })
      }
    }
```

`store.js`

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const state = {
  // 初始化A和B组件的数据，等待获取
  AMsg: '',
  BMsg: ''
}

const mutations = {
  receiveAMsg(state, payload) {
    // 将A组件的数据存放于state
    state.AMsg = payload.AMsg
  },
  receiveBMsg(state, payload) {
    // 将B组件的数据存放于state
    state.BMsg = payload.BMsg
  }
}

export default new Vuex.Store({
  state,
  mutations
})
```

[使用vuex进行兄弟组件通信]: https://segmentfault.com/a/1190000014838912

# 6. 状态管理vuex

> Vuex是Vue的状态管理器，采用**集中式存储**管理应用的所有组件的状态。它的核心是 store仓库，就是一个容器，包含着应用中大部分的状态 state。

**vuex具体内容如下：**

- Vuex本质是一个对象。Vuex有两个属性，一个是install方法，一个是Store这个类

- install方法的作用是将store这个实例挂载到所有的组件上，注意是同一个store实例。

- Store这个类拥有`commit`，`dispatch`这些方法，Store类里将用户传入的`state`包装成data，作为new Vue的参数，从而实现了`state` 值的响应式。改变状态的唯一途径就是提交`mutations`。

  - `commit`：提交`mutations`，修改数据。
  - `dispatch`（action）：异步任务，本质还是利用`commit`提交`mutations`。

  - `getters`：相当于是vue中data中的`computed`，通过`this.$store.getters.[属性名]`获取vuex仓库中的数据。
  - `state`：可以使用`this.$store.state.[属性名]`获取vuex仓库中的数据。

**简单的store模式**

在全局环境或模块里创建一个store对象，里面放置着需要被组件共享的状态，以及可以管理状态的action。组件通过这个store对象去访问、变更状态。

**缺点：**非响应式，当状态发生变化时，组件不会自动更新。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\3bb4200db61d4ba48580bf0ee28a7868.jpg)

## 6.1 vuex原理

**vuex中的store本质就是没有template的隐藏着的vue组件。**

Vuex（整体思想诞生于Flux，但是）实现方式**使用了Vue自身的响应式设计**，本质就是将state作为一个隐藏的vue组件的data，依赖监听、依赖收集都属于Vue对data属性`setter`/`getter`方法的代理劫持。

## 6.2 vuex和全局对象区别

- Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。(也就是所谓的MVVM)
- 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是**显式地提交 (commit) `mutations`**。

## 6.3 vuex工作流程

1. 在vue组件里面，通过dispatch来触发异步任务actions（如，ajax请求）提交修改数据的操作。
2. 访问后端接口，然后获取后端返回数据。
3. 然后通过commit触发mutations更新数据
4. 通过Mutate修改state里面的数据。
5. 最后由store触发每一个调用它的组件的数据更新（Vue Component）

![img](https://gitee.com/gitee_fanjunyang/JueJin/raw/master/images/Vuex%E5%8E%9F%E7%90%86_2.png)

`App.vue`

```js
methods: {
    add() {
      //commit一个mutations
      this.$store.commit("add", 10);
    },
    sub(){
      //dispatch一个action，本质还是commit一个mutations
      this.$store.dispatch("asyncSub",10)
    }
  }
```

`store.js`

```js
actions: {
	asyncSub({commit}, payload) {
		setTimeout(() => {
			commit("asyncSub", payload)
		}, 2000)
	}
},
mutations: {
	add(state, payload) {
		state.age += payload
	},
	asyncSub(state, payload) {
		state.age -= payload
	}
},
```

`vuex.js`

```js
let Vue;
...
class Store {
    constructor(options) {
        this._s = new Vue({
            data: {
                state: options.state
            }
        })
        ...
	}
}
const install = _Vue => {
    Vue = _Vue
    Vue.mixin({
        beforeCreate() {
            if (this.$options && this.$options.store) {
                this.$store = this.$options.store
            } else {
                this.$store = this.$parent && this.$parent.$store
            }
        }
    })
}
export default { install, Store }
```

[理解 vuex 实现原理]: https://juejin.im/post/6844903949938475022

[vuex的工作流程]: https://blog.csdn.net/m0_38053092/article/details/102494739

# 7. vue-router原理

> 前端路由就是当url改变的时候，页面更新但不发起请求。

![image-20200817215653874](E:\Cloud\工作\前端之路\前端笔记\fig\image-20200817215653874.png)

## 7.1 路由模式

前端路由主要有两种实现模式：hash 模式 和 history模式。

- 默认 hash 
- history。如果浏览器不支持 history 新特性，则采用 hash
- 如果不在浏览器环境下，就采用 abstract（Node环境下）

![img](https://upload-images.jianshu.io/upload_images/4099767-4e2101346868ac4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/442/format/webp)

### **1）hash模式**

> **原理：**通过监听`hashchange` 事件来监测hash值变化，然后在回调函数中匹配hash做相应的页面更新操作，从而实现前端路由。

#符号本身以及它后面的字符称之为hash：

```
http://www.xxx.com/#/login
```

- hash虽然出现在URL中，但不会被包括在HTTP请求中，对服务器端完全无用，因此，改变hash值不会刷新页面。
- 每次hash值的变化，会触发hashchange 这个事件
- 每一次改变hash（window.location.hash），都会在浏览器的访问历史中增加一个记录
- hash 模式下，仅 hash 符号之前的内容会被包含在请求中，对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。

```js
function matchAndUpdate () {
   // todo 匹配 hash 做 dom 更新操作
}
window.addEventListener('hashchange', matchAndUpdate)
```

### **2）history模式**

> **原理：**利用HTML5的history对象新增的**pushState()**与**replaceState()**方法实现改变url地址且不会发送请求。通过设置监听器获取url的变化，然后再进行相应的页面更新操作，来实现前端路由。

这个实现需要服务器的支持，需要把所有路由都重定向到根页面。

```js
function matchAndUpdate () {
   // todo 匹配路径 做 dom 更新操作
}
window.addEventListener('popstate', matchAndUpdate)
```

### **3）模式对比**

- `pushState()`设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分
- `pushState()`设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中
- `pushState()`通过`stateObject`参数可以添加任意类型的数据到记录中；而hash只可添加短字符串
- `pushState()` 可额外设置 `title` 属性供后续使用。
- `hash` 模式下，仅 hash 符号之前的内容会被包含在请求中，后端来即使没有做到对路由的全覆盖，也不会返回 404 错误；`history` 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致。

### 4）使用场景

- 从上文可见，hash模式下url会带有#，当你希望url更优雅时，可以使用history模式。
- 当使用history模式时，需要注意在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。
- 当需要兼容低版本的浏览器时，建议使用hash模式。
- 当需要添加任意类型数据到记录时，可以使用history模式。

### 5）Vue router 实现

我们来看一下`vue-router`是如何定义的：

```js
import VueRouter from 'vue-router'
Vue.use(VueRouter)

const router = new VueRouter({
  mode: 'history',
  routes: [...]
})

new Vue({
  router
  ...
})
```

[前端路由简介 - hash模式 和 history模式]: https://juejin.im/post/5b10b46df265da6e2a08a724

## 7.2 导航守卫（钩子函数）

> 导航守卫就是在路由跳转过程中的一些钩子函数，通过钩子函数在不同时段可以做不同的事。
>

分类：全局守卫，路由独享守卫，组件内守卫。

### 7.2.1 完整的导航解析流程

1. 导航被触发
2. 在将要离开的路由组件中调用**beforeRouteLeave**
3. 调用全局前置守卫**beforeEach**
4. 在重用的组件里调用 **beforeRouteUpdate (2.2+)**
5. 在路由配置里调用 **beforeEnter**
6. 解析异步路由组件 
7. 在将要进入的路由组件中调用**beforeRouteEnter**
8. 调用全局解析守卫**beforeResolve(2.5+)**
9. 导航被确认
10. 调用全局后置钩子**afterEach**
11. 触发 DOM 更新
12. 执行**beforeRouteEnter**的 **next **回调函数

[Vue - 路由守卫（路由的生命周期）]: https://juejin.im/post/6844903924760051725

### 7.2.2 全局守卫

> 是指路由实例（$router）上直接操作的钩子函数，触发路由就会触发这些钩子函数。

- 全局前置守卫：`router.beforeEach()` 
- 全局解析守卫：`router.beforeResolve()` 
- 全局后置钩子：`router.afterEach()` 

**（1）router.beforeEach()**

在路由跳转前触发，这个钩子作用主要是用于登录验证。

```javascript
router.beforeEach((to, from, next) => {
	next()
})
```

**参数**：**to,from,next**

- `to` 代表要进入的路由对象
- `from` 代表离开的路由对象
- `next` 是一个必须要执行的函数，否则不能进入路由**(页面空白)**
  - **next()：** 执行下一个钩子函数
  - **next(false)：**取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)；
  - **next('/')或next({path: '/'})：** 跳转到一个不同的地址;
  - **`next(error)`**: (2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 [`router.onError()`](https://router.vuejs.org/zh/api/#router-onerror) 注册过的回调。

**（2）router.beforeResolve**

这和 `router.beforeEach` 类似，区别是在导航被确认之前，**同时在所有组件内守卫和路由组件被解析之后**，解析守卫就被调用，即在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。

**（3）router.afterEach**

```javascript
router.afterEach((to, from) => {
  // ...
})
```

### 7.2.3 路由守卫

可以在单个路由配置上直接定义beforeEnter守卫

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

### 7.2.4 组件守卫

可以在组件内直接定义以下路由导航守卫：

- `beforeRouteEnter`
- `beforeRouteUpdate` (2.2 新增)
- `beforeRouteLeave`

```javascript
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

### 7.2.4  $route 和 $router 的区别

`$route` ：是“路由跳转对象”，跳转时的对象，包括路由信息参数。如 path，params，hash，query，fullPath，matched，name 等。

` $router` ：是“路由实例”，包括了路由的跳转方法，钩子函数，mode等。

## 7.3 路由跳转方法

**1）标签跳转router-link**

```html
<router-link to="user">点击验证动画效果 </router-link>  

<!-- 先要配置路由： path: '/user/:id'      -->
<!-- 接收参数：    this.$route.params.id  -->
<router-link :to="'/user/' + this.id"> <router-link/> 
```

**2）事件跳转**`this.$router.push()`

跳转到不同的url，但这个方法**会向history栈添加一个记录**，点击后退会返回到上一个页面。

**字符串和对象：**

```js
this.$router.push('/home')			// 字符串
this.$router.push({path:'/home'})	// 对象
```

**query 传参**，相当于get请求，页面跳转时参数会在地址栏中显示，通过`this.$route.query.id`获取

```js
this.$router.push({  // 变成 /user?id=2
    path:'/user',
    query:{
        id:this.id
    }
})
```

**params 传参**，相当于post请求，页面跳转时参数不会在地址栏中显示,通过`this.$route.params.id`获取

```js
this.$router.push({ 
    name:'/user',
    params:{
        id:this.id
    }
})
```

**3）**`this.$router.replace(path:'/user')`

同样是跳转到指定的url，但是这个方法**不会向history里面添加新的记录**，点击返回，会跳转到上上一个页面。上一个记录是不存在的。

**4）**`this.$router.go(n)`

相对于当前页面向前或向后跳转多少个页面，类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面，0为刷新。

**5）**`this.$router.forward()` 前进一步

**6）**`this.$router.back() ` 回退一步

[vue 路由跳转方式]: https://segmentfault.com/a/1190000020084110

## 7.3 动态路由匹配

将某种模式匹配到的所有路由，全部映射到同个组件。

例如，有一个 `User` 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 `vue-router` 的路由路径中使用“动态路径参数”来达到这个效果：

```js
const User = {
  template: '<div>User</div>'
}
const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
  ]
})
```

现在呢，像 `/user/foo` 和 `/user/bar` 都将映射到相同的路由。

一个“路径参数”使用冒号 `:` 标记。当匹配到一个路由时，参数值会被设置到 `this.$route.params`，可以在每个组件内使用。于是，我们可以更新 `User` 的模板，输出当前用户的 ID：

```json
template: '<div>User {{ $route.params.id }}</div>'
```

# 8. vue渲染

<img src="https://upload-images.jianshu.io/upload_images/13429147-32832d6b08b108c4.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img" style="zoom: 50%;" />

## 8.1 虚拟DOM

虚拟 DOM ，就是一个普通的 JavaScript 对象，包含了 `tag`、`props`、`children` 三个属性。（在`element.js` 中）

- Vue引入虚拟DOM的本质是**抽象了原本的渲染过程，实现了跨平台的能力**，不局限于浏览器的 DOM，也可以是服务端渲染SSR、安卓和 IOS 的原生组件、小程序。
- Vue采用**声明式渲染**只要控制应用程序中的流程和状态，不像命令式渲染需要明确每一步怎么做，所以应该尽量减少view和dom操作的耦合性。
- 虚拟DOM提高性能，**不是说不操作DOM，而是减少操作DOM的次数，减少回流和重绘**。而且通过虚拟DOM可以直接匹配到节点的唯一标识key来进行差异比对然后更新视图，但直接操作真实DOM肯定需要时间找到节点在页面的位置。
- 虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用diff 算法避免了没有必要的 dom 操作，从而提高性能。

**`Virtual DOM` 算法的三个步骤：**

- 用 `JS` 对象模拟 `DOM` 树 — `element.js`
- 比较两棵虚拟 `DOM` 树的差异 — `diff.js`
- 将两个虚拟 `DOM` 对象的差异应用到真正的 `DOM` 树 — `patch.js`

**几个关键的`Virtual DOM`属性**

- `tag` 属性即这个`vnode`的标签属性
- `data` 属性包含了最后渲染成真实`dom`节点后，节点上的`class`，`attribute`，`style`以及绑定的事件
- `children` 属性是`vnode`的子节点
- `text` 属性是文本属性
- `elm` 属性为这个`vnode`对应的真实`dom`节点
- `key` 属性是`vnode`的标记，在`diff`过程中可以提高`diff`的效率

**面试题：如果只有一个DOM操作，直接操作真实DOM性能是否更优？**

可以直接操作DOM，但获取了性能的同时失去了代码的可维护性和后期开发效率。Vue是采用声明式渲染的，如果单独用js操作某个真实DOM，该操作不能被后期检测到。而且采取虚拟DOM的本质就是实现了跨平台的能力，比如服务端渲染SSR、小程序等，顺带做一些能做的优化，单就一个操作讨论运行性能没有意义，在 VUE 的框架下就遵循 VUE 的范式；小范围直接操作 DOM 是允许的，但如果要跨平台渲染，就要注意了。

[深入剖析：Vue核心之虚拟DOM]: https://juejin.im/post/6844903895467032589#heading-14
[服务端渲染（SSR)]: https://juejin.im/post/6844903731075481608
[Vue中只有一次DOM操作，有必要经过一层虚拟DOM吗？]: https://segmentfault.com/q/1010000023694135

## 8.2 vue渲染过程（Diff算法）

**Diff算法：用来比较同层级的新旧节点差异的高效算法。**

- 首先需要使用`initRender()`、`renderMixin()`等进行组件初始化和渲染函数初始化

- 采用`compileToFunction()`将template解析编译成render函数，此时检查缓存，如果没有缓存就调用`compile()`获得render函数的字符串形式，其中包括`parse()`、`optimize()`、`generate()`，之后通过new Function的方式生成render函数。

  - `parse()`，把 template字符串解析成 AST

  - `optimize()`，标记静态节点，之后在diff算法中会直接忽略标记为static的节点比对

  - `generate()`，根据 AST 结构拼接生成 render 函数的字符串

- 这个阶段属于独立构建的模板解析编译部分，也可以使用运行时构建，直接手写render函数省去前面的模板编译，但template更加方便和符合语义化。

- 运行生成的render函数，得到新的虚拟dom树，将它传入`_update()`方法中，调用`patch()`比较新旧节点，然后根据差异进行更新渲染，这里就用到了diff算法。

  **在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记。如果需要两棵树的完全比较，那么 `diff` 算法的时间复杂度为`O(n^3)`，但Diff算法是在同层比较，所以所以时间复杂度是`O(n)`**

  - 在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。

  - 订阅者watcher会调用`patch()`比较新旧节点，

    - 当oldVnode和vnode只存在一个时，用vnode替换oldVnode（旧节点不存在，插入新节点；新节点不存在，删除旧节点）

    - 当oldVnode和vnode都存在时，判断两个节点是否是同一个节点（比如key节点标识、tag标签名），不是的话将vnode转换为真实节点替换掉旧节点，是的话直接调用`patchVnode()`去更新旧节点。具体的逻辑是，
      1. 如果oldVnode跟vnode完全相等，那么不需要做任何事情。

      2. 如果vnode是文本节点或注释节点，只需要更新真实dom节点里的文本内容就可以

      3. 如果oldVnode有子节点而vnode没有，则删除真实dom节点里的子节点

      4. 如果只有vnode有子节点，则将vnode的子节点真实化之后添加到真实dom里去

      5. 如果两者都有子节点，则执行`updateChildren()`比较子节点

         首先给 `oldCh`和 `newCh` 分别分配一个 `startIndex` 和 `endIndex` 来作为遍历的索引，当`oldCh` 或者 `newCh` 遍历完后(遍历完的条件就是 `oldCh` 或者 `newCh` 的 `startIndex >= endIndex` )，就停止`oldCh` 和 `newCh` 的 `diff` 过程。

         比较oldCh和 newCh的首尾节点是否有相同的节点，判断是否是相同的节点，然后进行增删改移操作。

         - key 节点标识相同 

         - tag 节点的标签名相同 

         - isComment 是否为注释节点相同 
         - 当标签是`<input>`的时候，type必须相同

         - 是否data（当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息）都有定义

![image-20200817092856168](E:\Cloud\工作\前端之路\前端笔记\fig\image-20200817092856168.png)

`vm._render`会执行前面生成的`render`渲染函数，并生成一个`Virtual Dom tree`,而`vm._update`会将这个`Virtual Dom tree`转化为真实的`DOM`节点。上述渲染过程的方法会被封装，然后传入为实例创建的Watcher对象，当实例中的状态发生变化时就会重新渲染页面。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\vue-render.jpg)

### 8.2.1 算法复杂度O(n^3)

用来将一棵树转化为另外一棵树的树的三种操作：[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- **删除：**删除一个节点，将它的children交给它的父节点
- **插入：**在children中 插入一个节点
- **修改：**修改节点的值

直观的方式是用动态规划，通过这种记忆化搜索减少时间复杂度。确切地说，树的最小距离编辑算法的时间复杂度是`O(n^2m(1+logmn))`，我们假设`m 与 n 同阶`， 就会变成 `O(n^3)`。

老树的每一个节点都去遍历新树的节点，直到找到新树对应的节点。那么这个流程就是 `O(n^2)`，再紧接着找到不同之后，再计算最短修改距离然后修改节点，这里是 `O(n^3)`

[diff 时间复杂度 O(n^3) 是如何计算出来的]: https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/151

## 8.3 key的作用

key是节点的唯一标识，用于在vue渲染时比对两个新旧虚拟DOM是否是同一个节点，如果是同一个节点就调用patchVnode去更新旧节点，否则将vnode转换为真实节点替换掉旧节点。（有利于patch的优化，加速虚拟DOM渲染）

- v-for中 key属性只能使用 `number`或者`string` 类型
- v-for中key 必须使用v-bind 的属性绑定形式,指定key的值

```html
<p v-for="(item,index,key) in list" :key="item.id"></p>
```

**问题：在循环中key值最好不要用index的原因？**

如果key值使用index的话，就可能无法使原始的虚拟DOM中的key值和新的虚拟DOM中的key值一致，从而不能充分发挥diff算法的优势

**举例：**比如一个数组里有数据a  b  c，用index表示的key分别为0  1  2。当删除a时，b c的key分别为0  2，从而导致元素的新旧key值不一样，即key值不稳定，所以key值就失去其存在的意义了。

**比较合适的key值有：**id或者不一样的内容

[直接操作DOM一定比虚拟DOM操作耗时，diff算法，key值，虚拟 DOM的定义]: https://www.cnblogs.com/zhangycun/p/10963670.html

## 8.4 scoped渲染规则

1. 给HTML的dom节点添加一个不重复的data属性（例如: data-v-5558831a）来唯一标识这个dom 元素
2. 在每句css选择器的末尾（编译后生成的css语句）加一个当前组件的data属性选择器（例如：[data-v-5558831a]）来私有化样式

# 9. 动态组件和异步组件

## 9.1 动态组件

> Vue.js 提供了一个特殊的元素 `<component> `用来动态地挂载不同的组件。

`is`的值可以是一个已经注册的组件的名字或者一个组件的选项对象。

```html
<keep-alive>
	<component :is="curComponent"></component>
</keep-alive>
```

### keep-alive缓存

> 动态组件缓存。`keep-alive `会在切换组件的时候缓存当前组件的状态，再次进入这个组件时不需要重新创建组件，只需要从前面的缓存中读取并渲染。

**常用的属性有：**

- include：设置会被缓存的组件。
- exclude：设置不会被缓存 的组件。

**keep-alive相关的生命周期钩子函数：**

- activated： 进入页面时触发。（常用来实现每次进入页面的时候重新获取最新的数据）
- deactivated：退出页面时触发。

## 9.2 异步组件

**优点：**按需加载，提高首屏加载速度；具有缓存机制，无需多次加载。

```js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})
```

# 10. Vue项目结构目录

```
├─build 			// 存放webpack的相关配置以及脚本文件，在实际开发只偶用到webpack.base.conf.js，配置less、babel等
├─config 			// index.js配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、
					// 是否开启gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。
├─dist				// 打包后的文件存放处
├─node_modules		// 存放npm install命令下载的开发环境和生产环境的各种依赖
├─src				// 工程项目的源码以及资源，包括页面图片、路由组件、路由配置、vuex、入口文件等
│ ├─assets
│ ├─components
│ ├─router
│ ├─App.vue
│ ├─main.js
├─static			// 静态资源，字体文件等     
├─.babelrc 			// ES6语法编译配置
├─.editorconfig		// ESLint检查忽略的文件
├─.gitignore		// git上传需要忽略的文件
├─.postcssrc.js
├─index.html		// 入口页面
├─package-lock.json
├─package.json		// 项目基本信息
└─README.md			// 项目说明
```

[webpack配置文件详细分析]: https://blog.csdn.net/shan1991fei/article/details/82630656

# 11. Vue2.0、Vue3.0区别

1. **项目目录结构**

  vue-cli3.0移除了配置文件目录，`config` 和 `build` 文件夹

  同时移除了 `static` 静态文件夹，新增了 `public` 文件夹，打开层级目录还会发现， `index.html` 移动到 `public` 中

2. **配置项**
   3.0 config文件已经被移除，但是多了`.env.production`和`.env.development`文件，除了文件位置，实际配置起来和2.0没什么不同；没了config文件，跨域需要配置域名时，从config/index.js 挪到了vue.config.js中，配置方法不变

3. **命令发生变化**

   ```
   - 下载安装  npm install -g vue@cli
   - 删除了    vue list
   - 创建项目  vue create				// 原来是 init webpack my-vue-project
   - 启动项目  npm run serve           // 原来是 npm run dev
   ```

4. **数据监听**
   Vue2.x大家都知道使用的是ES5的`object.defineproperty`中`getter`和`setter`实现的；而vue3.0的版本，是基于Proxy进行监听的，其实基于proxy监听就是所谓的lazy by default，什么意思呢，就是只要你用到了才会监听，可以理解"按需监听"，官方给出的诠释是：**速度加倍，同时内存占用还减半**。

5. **新加入了 TypeScript 以及 PWA 的支持**

6. **Tree Shaking友好：**去除没用到的代码的优化手段

# 12. vue.nextTick

> 在修改数据之后立即使用这个方法，获取更新后的 DOM。在下次 DOM 更新循环结束之后被调用的延迟回调。

**原理：**vue的 DOM 更新是一个异步的过程。只要数据发生变化，就会在当前事件循环中在任务队列中缓冲所有数据的改变（一个watcher 被多次触发，只会被推入到队列中一次），然后在下次访问微任务队列时更新DOM，即nextTick是DOM更新的回调函数，在下一次循环中执行。（使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替）。

**应用场景：**需要在视图更新之后，基于新的视图进行操作。

- 点击按钮显示原本以 v-show = false 隐藏起来的输入框
- 点击获取元素宽度

注意 mounted 不会承诺所有的子组件也都一起被挂载。如果希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted

```js
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the entire view has been rendered
  })
}
```

# 13. 响应式数据的不足

由于 JavaScript 的限制，Vue **不能检测数组和对象的变化**。

## 13.1 对象

**无法检测对象属性的添加或移除。**因为 Vue 在初始化实例时对 property 执行 getter/setter 转化，所以属性必须在 `data` 对象上存在才能让 Vue 将它转换为响应式的。

```js
var vm = new Vue({
  data:{
    a:1	 // `vm.a` 是响应式的
  }
})
vm.b = 2 // `vm.b` 是非响应式的
```

解决方案：

```js
// 向嵌套对象添加响应式属性
Vue.set(vm.someObject, 'b', 2)
// vm.$set 实例方法，是全局 Vue.set 方法的别名
this.$set(this.someObject,'b',2) 
// 添加多个对象属性
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) 
```

## 13.2 数组

不能检测以下数组的变动：

1. 当利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
2. 当修改数组的长度时，例如：`vm.items.length = newLength`

```js
var vm = new Vue({
  data: {
    items: ['a', 'b', 'c']
  }
})
vm.items[1] = 'x' // 不是响应性的
vm.items.length = 2 // 不是响应性的
```

解决方案：

- 通过索引修改数组项问题

```js
Vue.set(vm.items, indexOfItem, newValue)
vm.$set(vm.items, indexOfItem, newValue)
vm.items.splice(indexOfItem, 1, newValue)
```

- 修改数组长度

```js
vm.items.splice(newLength)
```

Vue 被包裹过的数组方法可以监测数组的变化，包括：`push()`、`pop()`、`shift()`、`unshift()`、`splice()`、`sort()`、`reverse()`

**要说Vue.set()和this.$set()区别：**将this.$set()函数绑定在Vue原型上；将Vue.set()函数绑定在Vue构造函数

[Vue.set()和this.$set()介绍]: https://juejin.im/post/6844903901175496711

# 14. vue组件继承

**执行顺序：**Vue.extend > Vue.mixin > extends > mixins > 本身的钩子函数。（并且会被后面的覆盖）

|    类型    | 描述                                                         |
| :--------: | ------------------------------------------------------------ |
| Vue.extend | Vue 构造器创建（继承Vue的）一个子类，可以通过new来新建一个实例，挂载到一个元素上。 |
| Vue.mixin  | （对Vue类的options进行混入）全局注册mixin之后创建的每个 Vue 实例都会有这些属性或方法。 |
|  extends   | `Array< Object>`对象数组类型，向Vue实例中混入多个组件，与组件中的对象和方法进行合并，可理解为**多继承** |
|   mixins   | `Object` | `Function`类型，扩展另一个组件，且只能继承单个组件，可理解为**单继承**。 |

```js
const extend = {
  created () {
    console.log('extends created')
  }
}
const mixin1 = {
  created () {
    console.log('mixin1 created')
  }
}
const mixin2 = {
  created () {
    console.log('mixin2 created')
  }
}
export default {
  extends: extend,
  mixins: [mixin1, mixin2],
  name: 'app',
  created () {
    console.log('created')
  }
}
// extends created
// mixin1 created
// mixin2 created
// created
```

## 14.1 Vue.extend

使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

**具体使用：**根据类new一个实例，并挂载到一个元素上。

```html
<div id="mount-point"></div>
```

```js
// 创建构造器
var Profile = Vue.extend({
  template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',
  data: function () {
    return {
      firstName: 'Walter',
      lastName: 'White',
      alias: 'Heisenberg'
    }
  }
})
// 创建 Profile 实例，并挂载到一个元素上。
new Profile().$mount('#mount-point')
```

```html
<p>Walter White aka Heisenberg</p> // 效果
```

## 14.2 Vue.mixin

全局注册一个mixin混入，注册之后创建的每个 Vue 实例都会有这些属性或方法。

```js
// 比如我们希望每一个Vue实例都有一个print方法，我们就可以这么做：
Vue.mixin({
    methods: {
        print() {
        	console.log(`我是一个通过mixin注入的方法！`)
        }
    }
})
```

## 14.1 Mixins高阶组件

Mixins（混入）：复用代码的主要方式。

可以混入多个，`Array< Object>`类型，其中的数组中的成员可以是不同类型的对象，可理解为**多继承**。

在混入后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。

当组件和混入对象含有同名选项时：

- 数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。
- 同名钩子函数将合并为一个数组，因此都将被调用。优先级：mixins > 本身的钩子函数

**使用场景：**在全局注册所有vue实例共享的methods、filter或者hooks等方法。

## 14.2 Extends

`Object | Function`类型。可理解为**单继承**。

**使用场景：**当我们不需要全局去混入一些配置，比如想要获得一个component，可以使用Vue.component()，也可以使用Vue.extend()。

## 14.3 区别

[vue mixins和extends的妙用]: https://juejin.im/post/6844903537516740615

# 15. 数据流机制

**单向数据流**

所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。

**props的问题**

- 不能在一个子组件内部改变 prop
  - 如果需要赋值给子组件中的其他变量，需要利用计算属性computed进行重新赋值。
- 默认值传递问题，默认用null会报错。
  - 当props是数组或者对象时，我们用default的方式去定义
  - 用 v-if 进行判断然后再使用

window.isUpdatingChildComponent = false; 相当于一个Flag;只有当在父组件中修改传递给子组件的Prop值的时候，才会被赋值为True; 在子组件Proxy.vue 中代理父组件传递的Prop值； 使用  this.$forceUpdate(); 强制更新； 这时候，触发代理中的setter；提示不可以在子组件中直接修改父组件传递的Prop值的警告。

# 16. 按需加载

1. **Vue异步组件技术**

   vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。**一个组件生成一个js文件**

   ```js
   {
       path: '/promisedemo',
       name: 'PromiseDemo',
       component: resolve => require(['../components/PromiseDemo'], resolve)
   }
   ```

2. **ES的`import()`**

   推荐使用这种方式（需要webpack > 2.4）

   - 下面2行代码，没有指定webpack中Chunk名（webpackChunkName），每个组件打包成一个js文件。

     ```js
     const ImportFuncDemo1 = () => import('../components/ImportFuncDemo1')
     const ImportFuncDemo2 = () => import('../components/ImportFuncDemo2')
     ```

   - 下面2行代码，指定了相同的webpack中Chunk名（webpackChunkName），会合并打包成一个js文件。

     ```js
     const ImportFuncDemo = () => import('../components/ImportFuncDemo1')
     const ImportFuncDemo = () => import('../components/ImportFuncDemo2')
     ```

3. **webpack提供的`require.ensure()`**

   多个路由指定相同的chunkName，会合并打包成一个js文件。

   ```js
   {
       path: '/promise',
       name: 'Promise',
       component: resolve => require.ensure([], () => resolve(require('../components/Promise')), 'demo')
   },
   {
        path: '/hello',
        name: 'Hello',
        component: resolve => require.ensure([], () => resolve(require('../components/Hello')), 'demo')
   }
   ```

[vue项目实现按需加载的3种方式：vue异步组件、es提案的import()、webpack的require.ensure()](https://segmentfault.com/a/1190000011519350)

# 17. Vue错误处理机制

**1）errorHandler：全局错误处理函数**，组件的渲染和观察期间未捕获错误的处理函数。这个error handler 可以作用到所有的Vue应用

```js
Vue.config.errorHandler = function (err, vm, info) {}
```

- `err`指代 error 对象
- `vm`指代 Vue 应用本身
- `info`是一个 Vue 特有的字符串

**2）warnHandler：捕获 Vue warning。**在生产环境是不起作用的。

```js
Vue.config.warnHandler = function(msg, vm, trace) {}; // trace代表了组件树
```

**3）renderError：**不适用全局，只适用于非生产环境。

```js
const app = new Vue({
    el: "#app",
    renderError(h, err) {
        return h("pre", { style: { color: "red" } }, err.stack);
    }
});
```

**4）errorCaptured**

**5）window.onerror (不仅仅针对 Vue)：**全局的异常处理函数，可以抓取所有的 JavaScript 异常。


