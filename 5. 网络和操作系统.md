# 1. 五层协议体系结构

应用层：直接面向用户，是应用程序和网络之间的接口（FTP、HTTP、DNS）

表示层：报文的格式转换、压缩、编码、加密。

会话层：发起、结束、管理**两个会话的通信。**

传输层：上3层是数据处理阶段，下3层是数据传输阶段，具有承上启下的作用。具体是发起、结束、管理**传输连接**。提供可靠的传输服务，差错控制，流量控制。（TCP、UDP）

网络层：同一网络下，通过**路由选择算法**，为数据包在子网传输中选择合适路径。（IP、ICMP、IGMP）

数据链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据**帧**的数据链路

物理层：通过传输介质进行物理连接，保证比特流的透明传输。

**OSI七层协议：**应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

**TCP/IP概念模型：**应用层、传输层、网络层、物理层

**五层协议体系结构：**应用层、传输层、网络层、数据链路层、物理层

# 2. TCP / UDP协议

## 2.1 TCP

### 2.1.1 报文段格式

![img](E:\Cloud\工作\前端之路\前端笔记\fig\0147a9ace8f64a0ab7380b644197ec10.jpg)

1. 源端口和目的端口：各占16bit，标识发送和接收终端中的不同应用进程。

2. 序号（sequence number）：占32bit，本报文段发送的数据组的第一个字节的序号（TCP连接传送的数据流中的每一个字节都会被编上一个序号）。

3. 确认号（acknowledgment number）：占32bit，ACK为1时有效，上次成功收到的数据【**最后一个字节**】序号+1，指明下一个期待收到的字节序号。

4. 数据偏移/首部长度：占4bit，指示了数据区在报文段中的起始偏移值，实际上就是TCP报文段首部的长度。

5. 保留：占6bit，为将来使用，目前设为0。

6. 标志位：共6个，每一个标志位占1bit，表示一个控制功能：

7. 1. URG：紧急指针标志，=1时指示报文段中有紧急数据，应尽快传送，=0时忽略紧急指针；
   2. ACK：确认号标志，=1时表示确认号有效，=0时表示报文段中不含确认信息，忽略确认号字段；
   3. PSH：push标志，=1时指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队；
   4. RST：复位标志，=1时重置由于主机崩溃或其他原因而出现错误的连接，或者用于拒绝非法的报文段和拒绝连接请求；
   5. SYN：同步标志，用于建立连接过程。当SYN=1且ACK=0时，表示这是一个连接请求报文段。若同意连接，响应的报文段中SYN=1且ACK=1；
   6. FIN：结束标志，=1时表明此报文段的发送方已经没有数据需要发送了，并要求释放连接。

8. 窗口：占16bit，表示滑动窗口大小，用来告知发送端接收端的缓存大小，以此控制发送端发送数据的速率。是动态改变的。

9. 校验和：占16bit，奇偶校验，校验范围包括首部和数据两个部分，由发送端计算和存储，并由接收端进行验证。

10. 紧急指针：占16bit，只有当URG =1时紧急指针才有效。他指出了本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），因此紧急指针指出了紧急数据的末尾在报文段中的位置。

11. 选项和填充：可选字段，长度为0~40B，必须以4B为单位，必要时可以填充0。通常可以包括最长报文段大小、窗口扩大选项、时间戳选项等。

12. 数据部分：可选，比如在连接建立和终止时，仅有TCP首部而没有数据部分。

### 2.1.2 TCP的可靠传输

- **确认和重传：**接收方发送一段时间后没有收到确认就会重传；

- **数据校验：**TCP报文头有校验和，用于检验报文是否损坏；

- **数据合理分片和排序：**tcp会按最大传输单元（MTU）合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。
  - **而UDP中**：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，使得每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报

- **流量控制：**当接收方来不及处理发送方的数据，可以通过滑动窗口，提示发送方降低发送的速率，防止包丢失；

- **拥塞控制：**当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。

### 2.1.3 TCP三次握手/四次挥手

#### 1）三次握手建立连接

![img](E:\Cloud\工作\前端之路\前端笔记\fig\9108d9e30fc14e51a3fdcd4d33bf7bbc.jpg)

1. 客户端向服务器端发起连接请求，附带一个同步标志SYN=1，序列号seq=x，（客户端进入**同步发送**状态）
2. 服务器端收到请求报文后，如果同意建立连接，就发送一个同步标志SYN=1，序列号seq=y，确认标志ACK=1，确认号ack=x+1（服务器端进入**同步收到**状态）
3. 客户端收到响应报文后，向服务器端发送一个确认报文，序列号seq=x+1，确认标志ACK=1，确认号ack=y+1，（客户端进入**连接建立**状态）

#### 2）四次挥手断开连接

![img](E:\Cloud\工作\前端之路\前端笔记\fig\86b6ab1f8116437a869c24a0d4112574.jpg)

1. 客户端向服务器端发起连接释放，附带一个结束标志FIN=1，序列号seq=u，（客户端进入**终止等待1**状态）
2. 服务器端收到请求报文后，如果同意释放连接，就发送序列号seq=v，确认标志ACK=1，确认号ack=u+1（服务器端进入**关闭等待**状态），此时处于半关闭状态，服务器还可以向客户端发送数据，客户端收到服务器的确认报文段后，（客户端进入**终止等待2**状态）
3. 服务器端向客户端发送连接释放报文段，附带一个结束标志FIN=1，序列号seq=w，确认标志ACK=1，确认号ack=u+1，（服务器进入**最后确认**状态）
4. 客户端收到连接释放报文后，向服务器端发送一个确认报文，序列号seq=u+1，确认标志ACK=1，确认号ack=w+1，（客户端进入**时间等待**状态），此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，才进入CLOSED状态。服务器接收到确认报文段后，立即进入CLOSED状态。

#### 3）常见问题

- **为什么需要三次握手？ == 为什么TCP客户端最后还要发送一次确认？**

  主要防止已经失效的连接请求报文段突然又传送到了服务器，从而产生错误。所以最后一次请求需要进行确认。

  A发送请求，但连接请求报文堵塞，B并未收到确认，所以A再重传一次连接请求并根据这次请求建立了连接，数据传输完后就释放了连接。此时第一次发送的堵塞住的报文到达了B，B会误以为A又一次发送了连接请求，然后发出确认报文，然后新的连接就建立了。

  因为三次握手才能确认双方的接收与发送能力是否正常，如果只有两次握手的话，服务端无法确认客户端是否有接收数据的能力。

- **第三次握手失败会出现什么问题？**

  - 如果ack包在网路中丢失，时间超过了计时器，server端会重发SYN+ACK报文，默认5次，如果仍未收到响应，那么将发送RST报文关闭连接（RST异常连接重置报文）；

  - 如果有大量的客户端不进行第三次握手，server端会一直重发syn+ack报文，并且半连接队列会逐渐堆满，无法处理正常请求。

- **为什么客户端最后还要等待2MSL？**

  - 保证客户端发送的最后一个ACK报文段能够到达服务器，若丢失会进行重传。

  - 防止已经失效的连接请求报文段突然又传送到了服务器，从而产生错误。

  第一，保证客户端发送的最后一个ACK报文段能够到达服务器，因为这个ACK报文段可能丢失；一旦丢失，服务器重新发送连接释放报文段时（**超时重传**），客户端就能在这个2MSL时间段内收到这个重传的报文段，接着给出回应报文段，并且会重启2MSL计时器。

  第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文段后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文段。

- **为什么建立连接是三次握手，关闭连接确是四次挥手呢？**

  建立连接时，服务器收到建立连接请求的SYN报文段后，把ACK和SYN放在一个报文段里发送给客户端；

  而释放连接时，在客户端发送完数据请求释放连接的情况下，服务器可能仍还有数据需要发送给客户端，因此将**ACK和FIN分开发送**，从而导致多了一次。

## 2.2 UDP数据段格式

![img](E:\Cloud\工作\前端之路\前端笔记\fig\af2e94deab454944911ea82b239b8f9f.jpg)

1. 源端口和目的端口：各占16bit，标识发送和接收终端中的不同应用进程。
2. UDP总长度：占16bit，指示UDP报文（首部和数据）的总长度。
3. 校验和：该字段用于发现头部信息和数据中的错误。
4. 数据部分：可选。

## 2.3 TCP和UDP的区别

- **TCP（传输控制协议）：**可靠的、面向连接的协议；传输效率低

- **UDP（用户数据报协议）：**不可靠的、无连接的服务；传输效率高

1. **TCP是面向连接的协议，UDP是无连接协议 **

在发送数据前，TCP会通过三次握手在两个主机之间先建立一条连接，而UDP不会，而是直接发送数据。

2. **TCP只能是一对一通信，UDP支持一对一，一对多，多对一和多对多交互通信**

3. **TCP首部最小20字节，最大60字节，UDP首部开销小，仅8字节**

4. **TCP的数据传输是面向字节流的，UDP是面向报文段的**

TCP下的数据以无边界的字节流进行传输。每个TCP套接口会有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文段发送出去。对于接收方的缓冲区，只要能够容纳，它会一次性接收所有到达的数据。

UDP对于应用层交下来的报文，在添加首部后就向下交付给网络层。既不合并，也不拆分，而是保留了这些数据段的边界，接收方也会一个一个地接收这些数据段。

5. **TCP传输是可靠，UDP则是不可靠的**

TCP给每个报文段编有序号，接收方会对接收到的报文段按序整理，同时对已接收到的报文段，接收方会发回一个带有相应确认号的报文段，如果发送方实体在合理的往返时延(RTT)内未收到确认，那么对应的报文段将会被重传。另外，TCP会提供拥塞控制和流量控制，来控制发送方的发送速率和数据量。

UDP随时发送数据，且不会进行备份，发送数据后也不会关心对方是否已经正确接收到数据了。并且，UDP不会根据网络环境调整发送速率，这样可能会导致丢包等情况发生。

6. **应用场景**

**TCP：效率要求相对低，但对准确性要求相对高的场景。**因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。

**UDP：效率要求相对高，对准确性要求相对低的场景。**举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。

# 3. HTTP / HTTPS

## 3.1 HTTP

HTTP（超文本传输协议）是基于TCP的应用层协议，主要用来规范客户端和服务器的数据传输格式。

### 1）HTTP报文格式

**HTTP请求报文**由请求行、请求头、请求正文三个部分组成。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\df44746aa33d480c89cfbf32ddd64a01.jpg)

1. 请求行：包括请求方法、资源路径URL、协议版本。

2. 请求头：由一堆键值对组成，用来说明服务器要使用的一些附加信息，比如请求的目的地、客户端信息、Cookie等。

   `accept-charset`、`accept-encoding`、`accept-language`、`authorization`、`content-length`、`Host`（请求的主机名，允许多个域名同处于一个IP地址，即虚拟主机）、`Cookie`、`User-Agent`（产生请求的浏览器类型）...

3. 请求正文：存放一些需要和服务器端交互的数据。

**HTTP响应报文**由状态行、响应头、响应正文三个部分组成。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\d155b70164e64777b3534083dc5cd69f.jpg)

1. 状态行：包括协议版本、状态码、状态消息

2. 响应头：由一堆键值对组成，用来说明客户端要使用的一些附加信息，比如响应时间、数据类型等

   `content-length`、`content-encoding`、`content-type`、`Date`、`Refresh`、`Server`（服务器的信息）、`Location`（令客户端重定向的URI）

3. 响应正文：存放服务器返回给客户端的文本信息

### **2）请求方法**

| **请求方法** | **方法描述**                                                 | **支持的HTTP版本** |
| ------------ | ------------------------------------------------------------ | :----------------: |
| GET          | 常用于向服务器请求资源、查询信息                             |      1.0，1.1      |
| POST         | 向服务器新增更新数据，偏向于新增数据，不有幂等性，两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI |      1.0，1.1      |
| PUT          | 向指定资源位置新增更新数据，偏向于更新数据，具有幂等性，多次请求具有相同副作用。 |      1.0，1.1      |
| HEAD         | 与GET方法类似，只是响应报文没有数据主体，用于确认URI的有效性及资源更新时间等 |      1.0，1.1      |
| DELETE       | 请求服务器删除指定的资源                                     |      1.0，1.1      |
| OPTIONS      | 用来询问服务器支持的方法（非简单请求的预检）                 |        1.1         |
| TRACE        | 追踪路径，回显服务器收到的请求，确认客户端发送出去的请求是否被修改过 |        1.1         |
| CONNECT      | 要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信  |        1.1         |
| PATCH        | 用于对资源进行部分修改                                       |                    |

#### GET和POST区别

- **安全程度不同：**GET请求参数放在URL中，POST放在request body中，所以POST会相对更安全。

- **应用场景不同，**GET一般用来从服务器上获得数据，而POST是用来向服务器上传递数据。
  - 一般用GET的方式实现数据**查询**；
  - 用POST的方式实现**增加、删除和修改数据**
- **大小不同**，GET方式传输的数据量较小（长度有限制<=2Kb），而POST可以传输大量的数据（无限制，靠服务器的设定值限制）
- **幂等性不同**，GET是幂等方法，POST是非幂等方法。
- **参数类型不同：**GET只接受ASCII字符，而POST没有限制。
- **数据包不同：**GET产生一个TCP数据包；POST产生两个TCP数据包，所以POST传输速度更慢。
  - GET：浏览器会把http header和data一并发送出去，服务器响应200 返回数据；
  - POST：浏览器先发送http header，服务器响应100 等待其余部分，浏览器再发送data，服务器响应200 返回数据。
  - **注意：**并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次

### 3）幂等性

幂等性是后端接口承诺只要接口调用成功，一次请求和重复的多次请求**对系统资源的影响是一致的，具有相同的副作用（而不是结果相同）**。具有幂等性的接口在设计时秉持的理念是：调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

副作用一般是非幂等方法才会出现的，幂等方法是不会有副作用的。以post方法为例，它的目的是在服务端创建一份资源，但是由于它不满足幂等性，所以当使用post方法重复提交相同的数据时（比如重复提交表单），会在服务端创建出多份资源，这就是post方法的副作用。

- **幂等方法：**GET、PUTE、DELETE、OPTIONS
  - GET方法用于获取资源，不会改变资源的状态，不论调用一次还是N次都没有副作用。
  - DELETE方法用于删除资源，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子。
- **非幂等方法：**POST、PATCH

#### post和put区别

二者均可用于创建资源，更为本质的差别是在幂等性方面。

- **POST所对应的URI并非创建的资源本身**，而是资源的接收者。比如：POST [http://www.forum.com/articles](https://link.jianshu.com?t=http%3A%2F%2Fwww.forum.com%2Farticles)的语义是在[http://www.forum.com/articles](https://link.jianshu.com?t=http%3A%2F%2Fwww.forum.com%2Farticles)下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会**在服务器端创建两份资源**，它们具有不同的URI；所以，POST方法不具备幂等性。
- **PUT所对应的URI是要创建或更新的资源本身**。比如：PUT [http://www.forum/articles/4231](https://link.jianshu.com?t=http%3A%2F%2Fwww.forum%2Farticles%2F4231)的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

[HTTP幂等性]: https://www.jianshu.com/p/eef1d6eecdc7

#### put和patch区别

主要是幂等性的区别

- PUT和PATCH都是更新资源，而PATCH用来对已知资源进行局部更新。
- PUT需要把整个json发过去，可以做到直接覆盖。而PATCH只需要发送json中需要更改的字段就行。

### 4）完整的URL请求过程

1. 对网址进行DNS域名解析，得到相应的IP地址
2. 根据这个IP地址找到对应的服务器，发起TCP三次握手，建立TCP连接
3. 发起HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码（如果不是html代码需要解析成html代码）
5. 服务器关闭TCP连接。
6. 浏览器解析脚本：
   - 解析html构建DOM树
   - 解析CSS生成CSSOM规则树
   - 将DOM树与CSSOM树合并在一起生成渲染树
   - 遍历渲染树开始布局(layout)，计算每个节点在页面中的位置大小信息
   - 绘制：将渲染树每个节点绘制到屏幕

参考https://www.cnblogs.com/WindSun/p/11489356.html

#### DNS解析

DNS（ Domain Name System，域名系统）域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

- DNS协议运行在UDP协议之上，使用端口号53

**DNS解析/主机名解析：**通过域名得到该域名对应的IP地址的过程

```
www.dnscache.com (域名)  -> DNS解析 -> 11.222.33.444 (IP地址)
```

**DNS解析过程：**

- **本地解析**
  先到浏览器的DNS缓存中查询是否有对应记录，如有则直接返回ip地址，完成解析，如果没有则下一步；
  然后查看本地host文件，比如windows的host文件一般位于“C:\Windows\System32\drivers\etc”，如果这里也没有的话就需要到本地dns服务器上查找了。
- **本地DNS服务器解析**
  本地服务器可以分为两种：一种是公共DNS服务器，比如114 DNS（114.114.114.114）、Google DNS（8.8.8.8）；另一种是本地运营商提供的DNS服务器，比如移动、电信提供的服务器。如果没有在本地DNS服务器上找到，就去根域名服务器查找
- **根域名服务器**
  当信息传递给递归服务器后，会根据内置的根域名服务器ip地址，寻求根域名服务器的帮助。根域名不会直接解析域名，而是把不同的解析请求分配给根域名下面的 其他服务器来完成。
  以www.taobao.com为例，当**根域名服务器**接收到本地dns的解析请求后，获知后缀是.com，于是就把负责.com的**主域名服务器**ip地址返回给本地dns。本地dns获得返回的ip地址，再去找对应的主域名服务器，主域名服务器又把负责该域名的**权威服务器**ip返回给本地dns。最后，本地dns根据ip找到对应的权威服务器，权威服务器把对应的主机ip返回给本地dns，至此完成了域名解析的全过程

### 5）状态码

| **状态码分类** | **分类描述**                                     |
| -------------- | ------------------------------------------------ |
| 1**            | 指示信息，服务器收到请求，需要请求者继续执行操作 |
| 2**            | 成功，操作被成功接收并处理                       |
| 3**            | 重定向，需要进一步的操作以完成请求               |
| 4**            | 客户端错误，请求包含语法错误或无法完成请求       |
| 5**            | 服务器错误，服务器在处理请求的过程中发生了错误   |

**常见的状态码**

- 100：【Continue】请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

- 101：【切换协议】请求者要求服务器切换协议，服务器已确认并准备切换。 

- 102：代表处理将被继续执行（ 由WebDAV（RFC 2518）扩展的状态码）

- 200：【OK】请求被成功处理

- 201：【Created】请求已经被成功处理，并且创建了新的资源。新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 Location 首部的值。

- 203：表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。 （HTTP 1.1新增）

- 204：【No Content】 请求已被处理成功，但是没有数据实体返回，此时浏览器页面也不会发生更新

- 206：【Partial Content】当客户端进行了范围请求且被成功处理时返回， 比如断点续传或多线程下载时会看到该状态码

- 301：【Moved Permanently】表示请求的资源已经永久搬到了其他位置，新的URI应该提示在响应头的Location字段

- **302**：【Found】表示请求的资源临时搬到了其他位置，新的临时URI应该提示在响应头的Location字段（虽然协议禁止请求重新发送，但实际使用时浏览器都会这么做）

- 303：【See Other】与302意义一样，区别只是303明确客户端应该使用GET访问（请求 会自动再次发送）

- **304**：【Not Modified】表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，服务端允许访问，但没有满足条件。（其实和重定向没啥关系，常用于检查缓存是否有更新）

  [304具体应用场景]: https://www.jianshu.com/p/0015277c6575

- 307：【Temporary Redirect】与303意义一样，只是客户端在收到该状态码的响应时，会遵循标准，不会自动把POST变为GET再次放出请求

- 400：【Bad Request】表示请求报文存在语法错误或参数错误，服务器不理解

- 401：【Unauthorized】表示发送的请求需要有通过HTTP认证信息或者是认证失败了

- 403：【Forbidden】表示对请求资源的访问被服务器拒绝了，一般可能是因为权限问题

- 404：【Not Found】表示请求的资源在服务器上找不到

- 405：【Method Not Allowed】表示客户端请求的方法被禁止

- 409：【conflict】表示请求的资源与资源的当前状态发生冲突

- 410：【Gone】表示服务器上某个资源被永久性删除。

- 500：【Internal Server Error】服务器内部发生了错误

- 502：【Bad GateWay】网关错误

- 503：【Service Unavailable】表示服务器超负载或正停机维护，目前无法处理请求，可以将延时写在响应头的Retry-After字段返回

- 505：【HTTP Version not supported】服务器不支持请求的HTTP协议的版本，无法完成处理

**302详解：**根据协议标准，若客户端发出POST请求后，收到302状态码，不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，但实际上许多客户端在这种情况下都会把POST请求变为GET请求。新增的303和307其实就是明确了两种处理方式，303允许自动转换并发出请求，而307不允许。

**304详解：**缓存服务器向服务器请求某一个资源的时候，服务器返回的响应报文具有这样的字段：Last-Modified:Wed,7 Sep 2011 09:23:24，缓存器会保存这个资源的同时，保存它的最后修改时间。下次用户向缓存器请求这个资源的时候，缓存器需要确定这个资源是新的，那么它会向原始服务器发送一个HTTP请求（GET方法），并在请求头部中包含了一个字段：If-Modified-Since:Wed,7 Sep 2011 09:23:24，这个值就是上次服务器发送的响应报文中的最后修改时间。假设这个资源没有被修改，那么服务器返回一个响应报文：

```jsx
    HTTP/1.1 304 Not Modified
    Date：Sat, 15 Oct 2011 15:39:29
    (空行)                                      
    (空响应体)
```

用304告诉缓存器资源没有被修改，并且响应体是空的，不会浪费带宽。

### 6）离线缓存

#### Service Worker

Service Worker 是运行在浏览器里的一个独立线程，我们可以在其中编写JavaScript代码去自由控制缓存哪些资源，另外安装了Service Worker的页面，它的**所有请求都会经过Service Worker**，若存在缓存的话直接读取缓存，否则继续去请求资源。在这一部分，我们也可以加入对网络状况的检查，实现**离线缓存**。

#### Memory Cache

Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。内存缓存虽然**读取高效**，可是**缓存持续性很短，会随着进程的释放而释放**。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。同时，受限于内存容量，我们也不可能将太多太大的资源都存在Memory Cache里。

Memory Cache在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

#### Disk Cache

Disk Cache 也就是存储在磁盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性**上。在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。

### 7）浏览器缓存

> 对一些服务端未更新的资源进行复用，避免一些无谓的请求，优化了用户的体验。

![img](https://picb.zhimg.com/80/v2-d322e8342ee00d4c21b46f5cc709d61a_720w.jpg)

[HTTP 缓存机制一二三]: https://zhuanlan.zhihu.com/p/29750583

#### 强缓存

浏览器在加载资源时，会根据本地缓存资源header中的`Expire` 和 `Cache-control` 信息判断是否命中强缓存，如果命中则直接使用本地缓存中的资源不会再向服务器发送请求。如果不命中就向服务器发起请求，更新本地缓存。

命中强缓存：本地缓存未过期 `Cache-control`  > `Expire`，如果对浏览器**兼容性**要求很高的话，可以两个都使用。

**Expire**

缓存到期时间（绝对时间），过了这个时间，响应会失效；

Expire缺点：要求服务器与客户端的时钟保持严格的同步，并且时间到后，服务器还得重新设定新时间。

**Cache-Control**

缓存资源最大有效时间（相对时间，相对对的是文档的请求时间），包含的属性：

- max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
- no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜
- no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
- private：只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存
- public：可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
- must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证

#### 协商缓存

若强缓存没有命中，则根据上次响应头中的`Etag`或`Last-Modified`在请求头中设置`If-None-Match`或`If-Modified-Since`，然后在服务器端验证资源是否更新。如果没有更新，则返回304，告诉浏览器资源未更新，加载浏览器本地缓存。如果资源已经更新，返回200和新的数据，并更新响应头的`Etag`或`Last-Modified`属性，最后用新数据更新本地缓存。

**ETag/If-None-Match**

`ETag/If-None-Match` 的值是对资源取 hash的结果（摘要），相比后者可以减少网络负载。

当浏览器第一次请求资源时，服务器会返回一个`Etag`标识，当再次请求该资源时，通过`If-no-match` 字段将 `Etag` 发送回服务器，然后服务器进行比较，如果相等，则返回 `304` 表示未修改。

**Last-Modified/If-Modified-Since**

当浏览器第一次请求资源时，服务器返回的`header`上会带有一个`Last-Modified`字段，表示资源的**最后修改**的时间（绝对时间）；当浏览器再次请求该资源时，请求头中会带有一个`If-Modified-Since`字段，这个值是第一次请求返回的当浏览器再次请求该资源时，请求头中会带有一个 `If-Modified-Since` 字段，这个值是第一次请求返回的 `Last-Modified` 的值。服务器收到这个请求后，将 `If-Modified-Since` 和当前的 `Last-Modified` 进行对比。如果相等，则说明资源未修改，返回 `304`，浏览器使用本地缓存。

```
Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT
```

**Last-Modified和Etag区别**

- Last-Modified只能精确到秒。无法通过最后修改时间Last-modified 判断资源是否更新，可能时间变了但内容没变。
- Etag 的精度比 Last-modified 高，属于强验证，要求资源字节级别的一致，优先级高。

**注意**：如果响应头中有 Last-modified 而没有 Expire 或 Cache-Control 时，浏览器会有自己的算法来推算出一个时间缓存该文件多久，不同浏览器得出的时间不一样，所以 Last-modified 要记得配合 Expires/Cache-Control 使用。

**为什么有了Etag还需要last-modified?** 

一起使用时，服务器可以根据自己缓存机制的需要，选择ETag或Last-Modified来做缓存判断的依据，甚至可以两个同时参考。有时候 Last-Modified 可以弥补 ETag 判断的缺陷，比如一些图片等静态文件的修改，如果每次扫描内容生成 ETag 来比较，显然要比直接比较修改时间慢很多。**（Etag因为要计算hash所以需要占用cpu资源）**

#### 区别

它们都属于http缓存。

- 强缓存的优先级高于协商缓存，一般先通过强缓存判断资源是否命中，若不命中，再用协商缓存判断服务器资源是否更新；
- 强缓存如果命中则不会向服务端发起请求，协商缓存不管是否命中都会向服务端发起一次请求。
- **状态码的区别：**
  - `200`：强缓Expires/Cache-Control存失效时，返回新的资源文件
  - `200(from cache)`: 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功，现在的`200(from cache)`已经变成了`from disk cache(磁盘缓存)`和`from memory cache(内存缓存)`两种
  - `304(Not Modified )`：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304

[浏览器缓存机制：强缓存、协商缓存]: https://github.com/amandakelake/blog/issues/41

### 8）HTTP发展历程

[HTTP发展史]: https://juejin.im/post/6844903988953874445#heading-0

#### http0.9

- 仅支持GET请求，没有请求头、状态码，版本号
- 响应也是非常简单的，只包含 html 文档本身。

#### http1.0 

- 默认短连接；一次请求简历一次TCP连接，请求完就断开。
- 支持 HEAD，POST 方法，增加了状态码
- 传输内容不限于 HTML 文件

#### http1.1

- **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since，Expires来作为缓存判断的标准，HTTP1.1则引入了更多的**缓存控制策略**如Entity tag，If-None-Match，If-Unmodified-Since，If-Match、Last-Modify等更多可供选择的缓存头来控制缓存策略。

- **带宽优化及网络连接的使用**：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持**断点续传功能**，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

- **错误通知的管理：**在HTTP1.1中新增了24个错误状态响应码，如409（conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上某个资源被永久性删除。

- **Host头处理：**在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递**主机名**。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

- **长连接（Connection： keep-alive）：**HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和相应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

#### SPDY

针对HTTP1.X，优化了的请求延迟，解决了安全性。

- 多路复用：降低了延迟同时提高了带宽的利用率。
- header压缩： DEFLATE 算法
- 服务端推送
- **使用二进制分帧层**
- **数据流优先级：**对数据流设置优先值，决定了客户端和服务端处理不同的流采用不同的优先级策略。
- **基于HTTPS的加密协议传输**，大大提高了传输数据的可靠性。

SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\image-20200825215227258.png" alt="image-20200825215227258" style="zoom: 50%;" />

#### http2.0

HTTP 2.0是SPDY的升级版。**HTTP2.0和SPDY的区别：**

1. HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
2. HTTP2.0 消息头的压缩算法采用 HPACK ，非 SPDY 采用的 DEFLATE 

**HTTP 2.0特点：**

- **多路复用**

  HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1打了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来处理更多并发的请求，但是创建TCP连接本身也是有开销的。

- **头部数据压缩**

  在HTTP1.1中，HTTP请求和相应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。

  HTTP1.1不支持header数据的压缩，HTTP2.0使用**HPACK算法**对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

- **服务端推送**

  服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面地时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲和未充分使用地。

  为了改善延迟，HTTP2.0引入**server push**，它允许服务端推送资源给浏览器，在浏览器明确的请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。

- **数据流优先级**

  对数据流可以设置优先值，这个优先值决定了客户端和服务端处理不同的流采用不同的优先级策略。（例如浏览器在等待关键的 CSS 或者 JS 文件完成对页面的渲染时，服务器却在专注于加载图片）

- **使用二进制分帧层**

  在应用层与传输层之间增加一个二进制分帧层，在不改动 HTTP 的语义（HTTP 方法、状态码、URI 及首部字段）的情况下，将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式编码，改进传输性能，实现低延迟和高吞吐量。

  其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。

[HTTP1.0、HTTP1.1、SPDY和 HTTP2.0 的区别]: https://juejin.im/entry/5981c5df518825359a2b9476
[HTTP 的前世今生：一次性搞懂 HTTP、HTTPS、SPDY、HTTP2]: https://juejin.im/post/6844903712113360903#heading-4

**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。

#### http3.0/QUIC

HTTP3.0 核心是QUIC协议，是基于传输层UDP的安全可靠的HTTP2.0协议，由Google在2015年提出的SPDY v3演化而来的新协议。

- **基于UDP减少了TCP三次握手及TLS握手时间：**

  HTTP1.0/1.1/2.0/HTTPS都使用了TCP进行传输，HTTP2/HTTPS还需要使用TLS协议来进行安全传输。这就存在两个握手延迟，而基于无连接UDP协议的QUIC，连接建立时只需要一次交互，相当于半个握手的时间。

- **解决多路复用丢包时的线头阻塞问题：**

  QUIC中一个连接上的多个stream之间没有依赖。所以当发生丢包时，只会影响当前的stream，从而避免线头阻塞问题。

- **优化重传策略：**

  TCP中重传序号一致问题而导致的发送端不能明确ACK是初始包的确认还是对重传包的确认。为了避免这一问题，QUIC发送端设置初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增，这样每次在收到ACK时，就可以依据编号明确的判断这个ACK是来自初始封包或者是重传封包。

- **流量控制：**

  QUIC为了避免出现流量极慢的stream，采用了连线层 (connection flow control) 和 Stream 层的 (stream flow control) 流量控制，限制单一 Stream 可以占用的最大buffer size。

- **连接迁移：**

  QUIC 连接不以四元组作为标识（源 IP、源端口、目的 IP、目的端口）（连接变换时就需要切换TCP连接），而是使用一个 64 位的随机数Connection ID，对应每个stream，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。

## 3.2 HTTPS

https是在http的基础上加入了SSL协议，因为http协议以明文方式发送内容，不提供任何方式的数据加密，容易被第三方通过网络抓包截取和篡改报文。**SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密**，弥补了http的安全缺陷。

  - **HTTPS设计目标：**

    - 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么。
    - 数据完整性：即使发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里面装了什么东西，但他有可能中途碉堡，数据完整性就是指如果被掉包，我们能轻松发现并拒收。
    - 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹是，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方。

   - 原理：

     - 客户端将他所支持的算法列表和一个用作产生密钥的随机数发送给服务器；

     - 服务器从算法列表中选择一种加密算法，并将它和一份包含服务器公用密钥的证书发送给客户端；该证书还包含了用于认证目的的服务器标识，服务器同时还提供了一个用作产生密钥的随机数；

     - 客户端对服务器的证书进行验证（可参考数字签名），并抽取服务器的公用密钥；然后在产生一个乘坐pre_master_secret的随机密码串，并使用服务器的公用密钥对其进行加密（参考非对称加/解密），并将加密后的信息发送给服务器；

  - 客户端与服务器端根据pre_master_secret以及客户端与服务器的随机数值独立计算出加密和MAC密钥（可参考DH密钥交换算法）；

    - 客户端将所有的握手消息的MAC值发送给服务器；

    - 服务器将所有握手消息的MAC值发送给客户端。

      - **对称加密：**对称加密算法指加密和解密使用相同密钥的加密算法，如DES、AES等；

      - **非对称加密：**加密和解密使用不同密钥的加密算法，也称公私钥加密。假设双方要加密传输数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。常见的有RSA、DSA、ECC等。

      - **SSL和TLS**：

        - SSL（Secure Sockets Layer）安全套接层。用于保证（world wide web，WWW）的通讯安全。主要任务是提供私密性，信息完整性和身份认证。SSL是一个不依赖于平台和运用程序的西医，位于TCP/IP协议与各种应用层协议之间，为数据通信提高安全支持。

          - **SSL 证书中包含的具体内容**有：

            （1）证书的发布机构CA

            （2）证书的有效期

            （3）公钥

            （4）证书所有者

            （5）签名

          - 客户端在接受到服务端发来的SSL证书时，会**对证书的真伪进行校验**，以浏览器为例说明如下：

            （1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验

            （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发

            （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。

            （4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密

            （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比

            （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充

            （7）此时浏览器就可以读取证书中的公钥，用于后续加密了

          - SSL的体系结构中包含两个协议子层，其中底层是SSL记录协议层；高层是SSL握手协议层：

            - **SSL记录协议层**的作用是为高层协议提供基本的安全服务。SSL记录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在SSL运行。记录封装各种高层协议，具体是是压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。

            - **SSL握手协议层**包括SSL握手协议、SSL密码参数修改协议和SSL告警协议。握手协议层的这些协议用于SSL管理信息的交换，允许应用协议传送数据之间相互验证，协商加密算法生成密钥等。、

              **SSL握手协议的作用是协调客户和服务器的状态，使双方能够达到状态的同步。**

        - TLS（Transport Layer Security，安全传输层协议）用于在两个通信应用程序之间提供保密性和数据完整性。

   参考https://blog.csdn.net/qq_38289815/article/details/80969419

### 1）HTTPS传输过程

（SSL安全传输协议用来鉴别网站和网页浏览者的身份,以及在浏览器使用者及网页服务器之间进行加密通讯的全球化标准协议。）

![img](E:\Cloud\工作\前端之路\前端笔记\fig\5b503d10e4b0edb750e0d4f8.png)

<img src="https://cdn.nlark.com/yuque/0/2020/png/1743874/1595053832185-1e1be9c9-5a89-4e88-98c7-200da06c9d48.png" alt="img" style="zoom:80%;" />

1. **申请认证：**服务器生成一对公私钥，将公钥放在证书中（域名、申请者、公钥），生成请求文件.csr发给CA进行审核，CA审核过后，得到服务器最终的证书，对证书取hash得到摘要，然后对摘要进行加密得到数字签名，然后将包含数字签名的证书给服务器。
   - **CA证书包含：**服务器的公钥、域名，证书的数字签名、颁发机构、过期时间、申请者等。
   - 服务器的证书也可以自己制作，自己颁发的证书需要客户端验证通过，才可继续访问，而使用CA证书则不会弹出提示页面。
2. **发起请求：**客户端发起https请求（连接到服务器的443端口）
3. **发送证书：**服务器收到客户端请求后，会将从CA申请的服务器CA证书返回给客户端。
4. 客户端解析并对证书进行验证。浏览器会内置一个受信任的CA机构列表（白名单），并保存了这些CA机构的证书。

   - 浏览器会基于这些内置信息核对服务器证书。如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称秘钥。
5. 使用CA公钥对数字签名进行解密得到摘要，同时对证书取hash得到原始摘要，比对两者，若相同则在本地生成一个通信密钥，并取出证书中服务器的公钥对密钥进行加密，然后返回给服务器。
6. 服务器用自己的私钥解密后，相应地生成对称密钥。之后双方传输的所有http数据，均通过对称密钥进行加解密。

**问：如何保证两边生成对称密钥是相同的？**

对称密钥**enc_key=Fuc(random_C, random_S, Pre-Master)**，其中random_C和random_S分别在客户端和服务端随机生成，Pre-Master是在第5步随机生成的。第5步会向服务端发送以下字段：

- `ClientKeyExchange`：客户端产生的随机数字 Pre-master，用server的公钥加密，发送给服务器

- `ChangeCipherSpec`：客户端通知服务器后续的通信都采用协商的对称密钥和加密算法进行通信（注意这个消息里不包含对称密钥）

- `Finished`：结合之前所有通信参数的 hash 值与其它相关信息生成一段数据，采用协商密钥 session secret 与对应算法进行加密，即`EncryptedHandshakeMessage`，发送给服务器

**问：如何防止中间人攻击？**数字签名

**扩展：过程中的非对称和对称加密：**

- 协商秘钥的过程用了**非对称加密**，特点是私钥加密后的密文，只要是公钥，都可以解密，但是反过来公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。
  - 特点：安全性更高；但加解密十分费时
- 真正通信的过程是使用**对称加密**。加密和解密使用同一个秘钥。
  - 特点：加密速度快、效率高；秘钥的管理和分发非常困难，不够安全。

### 2）非对称加密和对称加密

**Hash加密算法：**MD5、SHA-256、SHA512

**非对称加密**

用私钥加密过的信息可以用很多公钥加密，而用公钥加密过的信息只有私钥能解密。私钥只有一把，而公钥有很多。

- 优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。

- 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

- 主要算法：RSA、Elgamal、背包算法、Rabin、HD,ECC（椭圆曲线加密算法）。常见的有：RSA，ECC
- 我们常见的数字证书、加密狗即是采用非对称加密来完成安全验证的。

**对称加密**

指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。

- 优点：算法公开、计算量小、加密速度快、加密效率高。 

- 缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。
- 具体算法有：DES，3DES，TDEA，Blowfish，RC5，IDEA。常见的有：DES，AES，3DES等等。

**区别**

对称加密算法相比非对称加密算法来说，加解密的效率要高得多。但是缺陷在于对于秘钥的管理上，以及在非安全信道中通讯时，密钥交换的安全性不能保障。所以在实际的网络环境中，会将两者混合使用。

## 3.3 HTTP和HTTPS的区别

1. https协议需要到CA申请证书或自制证书。
2. http的信息是明文传输，https则是具有安全性的ssl加密。
3. http是直接与TCP进行数据传输，而https是经过一层SSL（OSI表示层）进行数据加密，
4. 端口不一样，http是80（需要国内备案），https是443。
5. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

**无状态的含义：**客户端给服务器发送HTTP请求，服务器响应后，不会记录任何信息，没有记忆功能。（解决方案：cookie、session）

**无连接的含义：**限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。

# 4. 前端安全

- XSS跨站脚本攻击
- CSRF跨站请求伪造
- SQL注入，通过Web应用接口注入SQL语法，伪造执行恶意SQL命令。
- 暴力破解，设置验证码防止重复尝试，限制次数。
- 本地存储数据泄漏，如cookie等，需要对敏感信息进行加密。

设置恶意网站黑名单；使用同源策略。

## 4.1 XSS

**跨站脚本攻击**（Cross Cite Scripting，通常简称为：XSS）

在网页中注入恶意脚本，和正常的代码混在一起，浏览器不能分辨哪些脚本可信，然后在浏览器上执行。利用这些恶意脚本，攻击者可获取用户的敏感信息如Cookie、SessionId，甚至下载木马程式，进而危害数据安全。

**脚本注入方式：**

- HTML中内嵌的文本中，恶意内容以script标签形式注入。
- 标签的href、src等属性中，包含javascript：等可执行代码。
- 在onload、onerror、onclick等事件中，注入不受控制代码。

**XSS攻击分类：**

- 存储型XSS、反射型XSS、DOM型XSS。
- **区别：**存储型 XSS 的恶意代码存在目标网站数据库里（网站服务器取出并拼接在html中）；反射型 XSS 的恶意代码存在目标网站URL里；DOM型由浏览器取出url中的恶意代码并执行，属于JS自身的漏洞，如eval()。

### 防御策略

1. **浏览器端主动进行XSS识别：内容安全策略 CSP**

   内容安全策略 (CSP, Content Security Policy) ，用于检测和缓解某些类型的攻击，包括跨站脚本 (XSS) 和数据注入等攻击。CSP 的实质就是白名单制度，**开发者提供白名单给浏览器，告诉他哪些外部资源可以加载和执行。**它的实现和执行全部由浏览器完成，开发者只需提供配置。

   - **设置：**通过设置header中的`Content-Security-Policy`；也可以通过meta标签进行设置

   ```js
   Content-Security-Policy: default-src 'self'            // 默认加载策略：限制所有的外部资源，都只能从当前域名加载
   Content-Security-Policy-Report-Only: default-src 'self'// 仅产生报告而不具有强制性
   
   <meta http-equiv="content-security-policy" content="default-src 'self'">
   ```

   [内容安全策略（CSP）详解]: https://juejin.im/post/6844903841238876174#heading-0

2. **服务器端对于用户输入的内容进行过滤**

   - 进行数据格式校验和限制长度
   
   - 过滤JavaScript 事件的标签。例如 "οnclick=", "onfocus" 等等
   
   - 将重要的cookie标记为httpOnly, 不允许js脚本获取cookie
   
     ```
     Cookie.HttpOnly = True
     ```
   
   - 对数据进行html encode转义处理，过滤或移除特殊的Html标签， 例如:
   
     ```js
     &amp; 替代 &
     &lt;  替代 <
     &gt;  替代 >
     &quot 替代 "
     ```

3. **验证码，防止脚本冒充用户提交危险操作。**

4. **使用较为安全的开发框架**

## 4.2 CSRF

**跨站请求伪造**（Cross Site Request Forgery，通常简称为：CSRF）

**具体过程：**

1. 用户登录a.com，验证通过后，浏览器会保留用户的登录凭证Cookie
2. 用户在没有退出登录的情况下访问恶意网站b.com
3. 然后b.com要求访问a.com，向a.com发起一个请求
4. 根据b.com的请求，浏览器会把访问a时存在本地的cookie带到请求中，然后访问被攻击网站a.com
5. 从而伪造用户请求，在并未授权的情况下执行一些自定义事件：
   - 模拟表单提交盗取用户资金。实际上就是上面所说的POST CSRF攻击
   - 篡改目标网站上的用户数据。
   - 盗取用户隐私数据

**CSRF 的两个特点：**

1. CSRF（通常）发生在第三方域名
2. CSRF 攻击者不能获取到 Cookie 等信息，只是使用

![img](https://pic4.zhimg.com/80/v2-4c319300f4eb2989a0ce95aaa719635a_720w.jpg)

### 4.2.1 防御策略

- **加验证码验证**

  如验证码、密码、指纹等，验证码会强制用户必须与服务器进行交互，才能完成请求。但是用户体验不好。

- **同源检测**

  检查通过请求头Header中Origin Header和Referer Header字段检查请求是否是来合法的源。先用Origin字段确认来源域名，但是在IE 11同源策略和302重定向之后的源时无该字段，需要用Referer Header。但是攻击者可以隐藏，不能防御同源攻击。

  存在安全隐患：有些浏览器比如IE6或者FF2可以篡改Referer值；用户自己可以设置浏览器使其在发送请求时不提供Referer字段

- **Samesite Cookie：**为` Set-Cookie`响应头新增`Samesite` 属性，该属性设置Cookie不随着跨域请求发送。

  -  Strict 严格模式

  -  Lax宽松模式，比 Strict 放宽了点限制。假如这个请求是GET 请求且是同步请求（改变了当前页面或者打开了新页面），则可以带上cookie
  
- **token：**利用CSRF 攻击者不能获取到 Cookie 等信息，只是使用。将cookie换成token，

  - 直接利用token服务器进行解密验证。
  - 双token验证：服务器端比较http请求报文header中的`Authorization`和cookie中的token是否一致。

[前端 | CSRF 的攻击类型与防御]: https://zhuanlan.zhihu.com/p/61827277

### 4.2.2 三种攻击类型

1. **GET 类型的 CSRF**

   在受害者访问含有这个 img 的页面后，浏览器会自动向 [http://a.com](https://link.zhihu.com/?target=http%3A//a.com) 发出一次HTTP请求。[http://a.com](https://link.zhihu.com/?target=http%3A//a.com) 就会收到包含受害者登录信息的一次跨域请求。

   ```html
   <img src="http://a.com/withdraw?amount=10000&for=hacker" >
   ```

2. **POST 类型的 CSRF**

   访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。可见这种类型的 CSRF 与第一种一样，都是模拟请求，所以后端接口也不能将安全寄托在仅允许 POST 请求上。

   ```html
   <form action="http://a.com/withdraw" method=POST>
       <input type="hidden" name="account" value="airing" />
       <input type="hidden" name="amount" value="10000" />
       <input type="hidden" name="for" value="hacker" />
   </form>
   <script> document.forms[0].submit(); </script>
   ```

3. **链接类型的 CSRF（需要点击链接）**

   ```html
   <a href="http://a.com/withdraw.php?amount=1000&for=hacker" taget="_blank">
    屠龙宝刀，点击就送！ 
   <a/>
   ```

### 4.2.3 CSRF token

CSRF Token的防护策略：

1. 将CSRF Token输出到页面中

   Token最好还是存在服务器的Session中。在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token；但对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，需要程序员在编码时手动添加Token。

2. 页面提交的请求携带这个Token

   对于GET请求，Token将附在请求地址之后，这样URL 就变成`http://url?csrftoken=tokenvalue`，而对于 POST 请求来说，要在 form 的最后加上：

   ```html
     <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>
   ```

   这样，就把Token以参数的形式加入请求了。

3. 服务器验证Token是否正确

   服务器先解密Token，对比session中的加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。

## 4.3 SQL注入

**数据库注入攻击。**把SQL命令伪装成正常的http请求参数（如表单提交或input输入），传递到服务端，欺骗服务器最终执行恶意的SQL命令，造成逃过验证或者私密信息泄露等危害。

- 对输入校验和限制长度
- 为每个应用使用单独的权限有限的数据库连接

## 4.4 DoS攻击

服务器停止攻击/拒绝服务攻击。海量的请求会造成服务器停止工作或拒绝服务的状态。

**DDOS攻击分布式拒绝服务攻击**

## 4.5 网络劫持

网络劫持一般分为两种：

- **DNS劫持：**输入京东被强制跳转到淘宝这就属于DNS劫持
  - **防御1：DNS强制解析，**通过修改运营商的本地DNS记录，来引导用户流量到缓存服务器
  - **防御2：302跳转的方式，**通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的,再对劫持的内存发起302跳转的回复，引导用户获取内容

- **HTTP劫持：**访问谷歌但是一直有贪玩蓝月的广告。由于http明文传输，运营商会修改http响应内容（即加广告）
  - **防御1：使用全站HTTPS，将HTTP加密，**使得运营商无法获取明文，就无法劫持响应内容

## 4.6 中间人攻击

中间人（Man-in-the-middle attack，MITM）指黑客悄悄的躲在通信双方之间，窃听甚至篡改通信信息。而通信双方并不知道消息已经被截获甚至篡改了。过程如下：

1. 黑客通过特殊途径在被攻击者的客户端安装根证书；
2. 客户端发起连接请求，代理服务器在中间截取请求，返回自己签名的伪造证书；
3. 客户端收到证书后会在系统中查找信任的根证书，因为黑客已经事先在被攻击者手机上安装了自己的根证书，因此客户端验证通过；
4. 客户端后续就会把中间服务器当成合法的服务器；
5. 而代理服务器会与真实的服务器通信，从而截获密钥，解密数据。

**两个前提条件**

- 攻击者要截获消息发送者和接收者的通信信道，比如我们使用代理服务器还有微信的服务器在某种程度上就可以认为是中间人；
- 攻击者要把自己的根证书安装到消息发送方，这样才能使得攻击方伪造的数字证书通过验证。当然如果消息发送方没有做数字证书完整性校验的话那么这步其实都可以省去了。

# 6. CDN

**服务器缓存：**分为代理服务器缓存和CDN缓存。

**CDN缓存服务器**（Content Delivery Network，即**内容分发网络**）：**起到分流作用，减轻服务器负载压力。**

- CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。
- 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载。

CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。

**缓存的寻找过程：**

1. 浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期（`Cache-control: max-age`）
2. 若缓存数据并没有过期，则直接将缓存数据返回给客户端；
3. 否则，CDN节点就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。 

[戳此处详细了解CDN工作过程](http://book.51cto.com/art/201205/338756.htm)

# 7. MAC地址

MAC地址是每台设备的唯一网络标识。

**MAC地址寻址：**首先通过广播包获取足够的MAC地址表，然后维护这个MAC地址表（反映各端口与MAC地址之间的关系，便于后面的数据转发）

# 8. 进程和线程

- **进程是CPU资源分配的最小单元**，进程拥有自己的地址空间，而**线程是CPU调度和执行的最小单元**，属于轻量级进程，同一个进程下的所有线程共享进程的地址空间，而线程只拥有少量的系统资源，包括栈空间，寄存器，pc等。因此线程调度比进程调度代价低很多，因为进程地址空间分配代价很大，同时这也会影响进程和线程的生命周期，进程间的生命周期是相互不影响的，而如果进程挂了，进程下的所有线程都要结束生命。
- 此外，进程间的通信方式和线程间的通信方式也会受到影响，因为跨地址空间，所以进程间的通信也就更复杂，常见的**进程间的通信方式有管道，虚拟内存，消息队列等，跨机器的话就是socket。**而**线程间通过共享全局变量就可以通信了，当然也包括一些同步机制，包括互斥锁，信号量等。**
- 简单的比喻：进程=火车，线程=车厢
  - 线程在进程下行进（单纯的车厢无法运行）
  - 一个进程可以包含多个线程（一辆火车可以有多个车厢）
  - 不同进程间数据很难共享（一辆火车上的成客很难换到另外一辆火车，比如站点换乘）
  - 同一进程下不同线程间的数据很容易共享（A车厢换到B车厢很容易）
  - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
  - 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
  - 进程可以拓展到多机，线程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能行进在不同轨道上）
  - 进程使用内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）--互斥锁
  - 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）--信号量
- **为什么有了进程还要有线程：**
  - 进程属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。
  - 线程是在进程这个层次上提供的一层并发的抽象：
    1. 能够使系统在同一时间做多件事情
    1. 当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行
    1. 可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高。

## 8.1 死锁

指两个或两个以上的进程在执行过程中，由于**竞争资源或者由于彼此通信而造成的一种阻塞的现象**，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些**永远在互相等待**的进程称为死锁进程。

# 9. 堆和栈

## 9.1 栈的特性及适用场景

- 先进后出。只能在栈顶进行添加或删除。
- **适用场景：**逆序输出

### 9.1.1 栈溢出

例如：由于C语言系列没有内置检查机制来确保复制到缓冲区的数据不得大于缓冲区的大小，因此当这个数据足够大的时候，将会溢出缓冲区的范围。

**原因**

- 堆栈尺寸设置过小
- 递归调用过深
- 函数调用层次过深：函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。
- 动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。
- 数组访问越界。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。
- 指针非法访问。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。

**危害**

- 程序崩溃，导致拒绝服务
- 跳转并且执行一段恶意代码

## 9.2 堆的特性及适用场景

## 9.3 队列

- 先进先出。在队尾进行添加，在队头进行删除，在队中间不能进行操作。
- **适用场景：**二叉树的层序遍历

# 10. WebSocket调研

与http有交集的地方但也有不一样的地方：都是基于TCP连接，都需要三次握手四次挥手。WebSocket是有状态的协议，支持二进制帧、扩展协议、部分自定义的子协议、压缩等特性。

**短轮询：**浏览器定时向服务器发送请求，看有没有更新的数据。

- 优点：短连接，服务器处理简单，支持跨域、浏览器兼容性较好。
- 缺点：有一定延迟、服务器压力较大，浪费带宽流量、大部分是无效请求。

**长轮询：**页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。这一过程在页面打开期间一直持续不断。

- 优点：减少轮询次数，低延迟，浏览器兼容性较好。
- 缺点：服务器需要保持大量连接。

**HTTP流：**浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。

- 优点：实现简单，在所有支持 iframe 的浏览器上都可用、客户端一次连接、服务器多次推送。
- 缺点：无法准确知道连接状态，IE浏览器在 iframe 请求期间，浏览器 title 一直处于加载状态，底部状态栏也显示正在加载，用户体验不好（htmlfile 通过 ActiveXObject 动态写入内存可以解决此问题）。

**XHR流：**浏览器必须支持 multi-part 标志，客户端通过 AJAX 发出请求 Request，服务器保持住这个连接，然后可以通过 HTTP1.1 的 chunked encoding 机制（分块传输编码）不断 push 数据给客户端,直到 timeout 或者手动断开连接。

- 优点：客户端一次连接，服务器数据可多次推送。
- 缺点：并非所有的浏览器都支持 multi-part 标志。

**Flash流：**在页面中内嵌入一个使用了 Socket 类的 Flash 程序，JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信，JavaScript 通过 Flash Socket 接收到服务器端传送的数据。

- 优点：实现真正的即时通信，而不是伪即时。
- 缺点：客户端必须安装 Flash 插件；非 HTTP 协议，无法自动穿越防火墙。

**SSE（Server-Sent Events）：**基于 HTTP 协议，利用服务器向客户端声明，接下来要发送的是流信息（streaming），会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，可以类比视频流。目前除了 IE/Edge其他浏览器都支持。SSE 是**单向通道**，只能服务器向浏览器发送，因为流信息本质上就是下载。

- 优点：适用于更新频繁、低延迟并且数据都是从服务端发到客户端。
- 缺点：浏览器兼容难度高。

**WebSocket，** 是 HTML5 开始提供的一种**独立**在单个 **TCP** 连接上进行**全双工通讯**的**有状态**的协议(它不同于无状态的 HTTP)，并且还能支持二进制帧、扩展协议、部分自定义的子协议、压缩等特性。

- 优点：
  - **较少的控制开销**，在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于 HTTP 请求每次都要携带完整的头部，此项开销显著减少了。
  - **更强的实时性**，由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。
  - **长连接，保持连接状态。**与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。
  - **双向通信、更好的二进制支持。**与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443，并且握手阶段采用 HTTP 协议，因此握手时不容易被屏蔽，能通过各种 HTTP 代理服务器。
- 缺点：部分浏览器不支持（支持的浏览器会越来越多）。
- 应用场景：较新浏览器支持、不受框架限制、较高扩展性。

[全双工通信的 WebSocket]: https://halfrost.com/websocket/

# 11. 离线存储

## 11.1 离线检测

navigtor.online属性可以检测设备是在线还是离线，true表示设备能上网。

'online'和’offline‘会在离/在线状态变化时，在window对象上触发。

## 11.2 应用缓存

Appcache 就是从浏览器的缓存中分出来的一块缓存区，要想在这个缓存中保存数据，可以使用一个描述文件（.appcache），列出要下载和缓存的资源。

在`<html>` 中的 manifest 属性中指定这个文件的路径。这个文件的 MIME 类型（设定某种扩展名的文件用一种应用程序来打开的方式类型）必须是text/cache-manifest。
