#   1. 数据类型

## 1.1 基本数据类型和引用类型

| 类型             | 描述                                                         |
| :--------------- | ------------------------------------------------------------ |
| **基本数据类型** | 数据存放在栈内存中。存取速度快，数据大小与生存期是确定的。   |
| **引用数据类型** | 数据指针存放在栈内存中，堆内存中的地址。存取速度慢，动态分配内存大小。 |

- **基本数据类型：**`Number`（精度是53位）、`String`、`Boolean`、`undefined`、`Null`、`symbol`（ES6新增，表示独一无二的值）
- **引用数据类型：**`Object`（Array、Date、Function等）

谷歌67新增：`BigInt`，表示安全存储、操作大整数（结尾+n，任意精度）

### 1.1.1 Undefined和Null区别

- **Undefined类型**：Undefined类型只有一个特殊的值undefined，表示未定义的值 。

  在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。

- **Null类型**：Null类型只有一个特殊的值null。

  从逻辑角度来看，null值表示一个空对象指针，在内存里的表示就是，栈中的变量没有指向堆中的内存对象，对象在内存中就处于游离状态，系统会回收该对象并释放内存。

## 1.2 类型转换

### 1.2.1 转Boolean

在条件判断时，除了 `undefined`， `null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象。

### 1.2.2 转String

1. 变量+""或者变量+"abc"

```javascript
var a = 123; // Number 类型
console.log(a + ''); // 转换成 String 类型
console.log(a + 'haha'); // 转换成 String 类型
```


上面的例子中，打印的结果，都是字符串类型的数据。实际上内部是调用的 String() 函数。也就是说，`c = c + ""` 等价于 `c = String(c)`。

2. 调用toString()方法

```javascript
变量.toString()
```


【重要】该方法**不会影响到原变量**，它会将转换的结果返回。当然我们还可以直接写成`a = a.toString()`，这样的话，就是直接修改原变量。

3. 使用String()函数

```javascript
String(变量)
```


使用 String()函数做强制类型转换时：

   - 对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。
   - 但是对于 null 和 undefined，则不会调用 toString()方法。它会将 null 直接转换为 "null"。将 undefined 直接转换为 "undefined"。

### 1.2.3 转Number

**1.使用 Number() 函数**

**情况一：字符串 --> 数字**

- 1.如果字符串中是纯数字，则直接将其转换为数字。
- 2.只要字符串中包含了非数字的内容（`小数点`按数字来算），则转换为 NaN。
- 3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。

**情况二：布尔 --> 数字**

- true 转成 1
- false 转成 0

**情况三：null --> 数字**

​	结果为：0

**情况四：undefined --> 数字**

​	结果为：NaN

补充：怎么理解这里的 **NaN** 呢？可以这样理解，使用 Number() 函数之后，**如果无法转换为数字，就会转换为 NaN**。

**2.使用ParseInt()函数**

parseInt()的转换情况如下。

**情况一：字符串 --> 数字**

- 1.**只保留字符串最开头的数字**，后面的中文自动消失。
- 2.如果字符串不是以数字开头，则转换为 NaN。
- 3.如果字符串是一个空串或者是一个全是空格的字符串，转换时会报错。

**情况二：Boolean --> 数字**

​	结果为：NaN

**情况三：Null --> 数字**

​	结果为：NaN

**情况四：Undefined --> 数字**

​	结果为：NaN

Number() 函数和 parseInt() 函数的区别：

就拿`Number(true)` 和 `parseInt(true)/parseFloat(true)`来举例，二者在使用时，是有区别的：

- Number(true) ：千方百计地想转换为数字。
- parseInt(true)/parseFloat(true) ：先转为字符串，再提取出最前面的数字部分；没提取出来，那就返回 NaN。

**parseInt()具有以下特性**：

（1）**只保留字符串最开头的数字**，后面的中文自动消失。例如：

```javascript
console.log(parseInt("2017在公众号上写了6篇文章")); //打印结果：2017

console.log(parseInt("2017.01在公众号上写了6篇文章")); //打印结果仍是：2017   （说明只会取整数）

console.log(parseInt("aaa2017.01在公众号上写了6篇文章")); //打印结果：NaN （因为不是以数字开头）
```

（2）如果对**非 String**使用 parseInt()或 parseFloat()，它会**先将其转换为 String** 然后再操作。【重要】

比如：

```
var a = 168.23;
console.log(parseInt(a)); //打印结果：168  （因为是先将c转为字符串"168.23"，然后然后再操作）

var b = true;
console.log(parseInt(b)); //打印结果：NaN （因为是先将a转为字符串"true"，然后然后再操作）

var c = null;
console.log(parseInt(c)); //打印结果：NaN  （因为是先将b转为字符串"null"，然后然后再操作）

var d = undefined;
console.log(parseInt(d)); //打印结果：NaN  （因为是先将b转为字符串"undefined"，然后然后再操作）
```

（3）自动带有截断小数的功能：**取整，不四舍五入**。

```javascript
var a = parseInt(5.8) + parseInt(4.7);
console.log(a);  // 9

var b = parseInt(5.8 + 4.7);
console.log(b); // 10
```

（4）带两个参数时，表示在转换时，包含了进制转换。

代码举例：

```javascript
var a = '110';

var num = parseInt(a, 16); // 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 num

console.log(num); // 272
```

如果你对打印结果感到震惊，请仔细看上面的代码注释。就是说，无论 parseInt() 里面的进制参数是多少，最终的转换结果是十进制。

我们继续来看下面的代码，打印结果是多少。

```javascript
var a = '5';

var num = parseInt(a, 2); // 将 a 当成 二进制 来看待，转换成 十进制 的 num

console.log(num); // 打印结果：NaN。因为 二进制中没有 5 这个数，转换失败。
```

**3. parseFloat()函数：字符串 --> 浮点数（小数）**

parseFloat()的作用是：将字符串转换为**浮点数**。parseFloat()和 parseInt()的作用类似，不同的是，parseFloat()可以获得有效的小数部分。

```javascript
var a = '123.456.789px';
console.log(parseFloat(a)); // 打印结果：123.456
```

parseFloat() 的几个特性，可以参照 parseInt()。

### 1.2.4 隐式类型转换

重点：**隐式类型转换，内部调用的都是显式类型的方法**。下面来详细介绍。

**1. isNaN() 函数**

```
isNaN(参数);
```

解释：判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型。也就是说：**任何不能被转换为数值的参数，都会让这个函数返回 true**。

**执行过程**：

（1）先调用`Number(参数)`函数；

（2）然后将`Number(参数)`的返回结果和`NaN`进行比较。

代码举例：

```javascript
console.log(isNaN('123')); // 返回结果：false。

console.log(isNaN('abc')); // 返回结果：true。因为 Number('abc') 的返回结果是 NaN

console.log(isNaN(null)); // 返回结果：false

console.log(isNaN(undefined)); // 返回结果：true

console.log(isNaN(NaN)); // 返回结果：true
```

**2.自增/自减运算符：`++`、`—-`**

```javascript
var a = "666";
a++;

console.log(typeof a); // 打印结果： number
console.log(a); // 打印结果：667
```

执行过程：

（1）先调用`Number(参数)`函数；

（2）然后将`Number(参数)`的返回结果进行 加 1 操作。

```javascript
var a = 'abc';
a++;
console.log(typeof a); // 打印结果：number
console.log(a); // 打印结果：NaN。因为 Number('abc')的结果为 NaN，再自增后，结果依然是 NaN
```

**3. 正号/负号：`+a`、`-a`**

> 注意，这里说的是正号/负号，不是加号/减号。


**任何值**做`+a`、`-a`、`/a`运算时，运算结果都会自动转换为 Number 类型。 内部调用的是 Number() 函数。

**举例**：

```javascript
var a = '666';
var b = +a;

console.log(typeof a); // 打印结果：string。说明 a 的数据类型保持不变。
console.log(a); // 打印结果：666

console.log(typeof b); // 打印结果：number。说明 b 的数据类型发生了变化。
console.log(b); // 打印结果：666
```

**4. 加号：`+`**

**情况一：字符串 + 数字**

- 当加号的两边，只要有一个是字符串的时候，就会调用 String() 函数将数字转为字符串，然后再计算。导致最终的运算结果是字符串。

**情况二：Boolean + 数字**

- Boolean 型和数字型相加时， true 按 1 来算 ，false 按 0 来算。这里其实是先调 Number() 函数，将 Boolean 类型转换为 Number类型，然后再和 数字相加。

**情况三： null + 数字**

- 等价于：0 + 数字

**情况四： undefined + 数字**

- 计算结果：NaN

**5. 运算符：`-`、`*`、`/`**

1、任何非 Number 类型的值做`-`、`*`、`/`运算时，会将这些值转换为Number然后再运算(内部调用的是 Number() 函数），运算结果是 Number 类型。（注：`任何值 + 字符串`是特例，运算结果是字符串）

```javascript
result1 = true + 1;  // 2 = 1+ 1
result2 = true + false; // 1 = 1+ 0
result3 = 1 + null; // 1 = 1+ 0
result4 = 100 - '1' // 99
```

2、任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。

```javascript
result1 = 1 + 2 + '3'  // 33
result2 = '1' + 2 + 3; // 123
```

3、任何值和NaN做运算的结果都是NaN。

## 1.3 数据类型判断 

### 1.3.1 typeof情况

判断表达式属于哪种类型，返回该类型的字符串形式（小写形式表示），返回的结果包括以下7种类型：undefined、boolean、string、number、symbol、function、object

- 对于基本类型：除了null以外，都可以返回正确的结果
- 对于引用类型：除了function以外，返回的都是object类型
- 对于null：返回的是object类型，**因为在判断数据类型时是根据机器的低位标识（32位）来判断的，null全是0，对象是000所以产生误判。**

`typeof` 对于基本类型，除了 `null` 都可以显示正确的类型

```js
typeof 1 		 // 'number'
typeof '1'		 // 'string'
typeof undefined // 'undefined'
typeof true 	 // 'boolean'
typeof Symbol()  // 'symbol'
typeof b		 // b 没有声明，但是还会显示 undefined

typeof null  	 // 'object'    	// 注意点
```

`typeof`对于对象，除了函数都会显示object

```js
typeof [] 			// 'object'     // 注意点
typeof {} 			// 'object'
typeof console.log  // 'function'
```

#### 1）typeof null

null 有属于自己的类型 Null，而不属于Object类型，typeof 之所以会判定为 Object 类型，是因为JavaScript 数据类型在底层都是以二进制的形式表示的，**二进制的前三位为 0 会被 typeof 判断为对象类型**，而 null 的二进制位恰好都是 0 ，因此，null 被误判断为 Object 类型。

- 000 - 对象，数据是对象的应用 
- 1 - 整型，数据是31位带符号整数 
- 010 - 双精度类型，数据是双精度数字 
- 100 - 字符串，数据是字符串 
- 110 - 布尔类型，数据是布尔值

### 1.3.2 instanceof

主要用于判断某个实例是否属于某个类型，也可用于判断某个实例是否是其父类型或者祖先类型的实例。

```js
// 其他基本类型都是返回false
null instanceof Null		   // Null is not defined
undefined instanceof Undefined // Right-hand side of 'instanceof' is not an object

console.log instanceof Function // true
[] instanceof Array				// true
({}) instanceof Object		 	// true
```

#### 1）实现原理

只要右边变量的prototype在左边变量的原型链上即可。因此，instanceof在查找的过程中会遍历左边变量的原型链，知道找到右边变量的prototype，如果查找失败，则会返回false。

- **不能判断具体是哪种类型，只能用来判断对象和函数，不能用来判断字符串和数字等**

#### 2）instanceof实现

```js
//instanceof
function myInstanceof(left, right){
  const leftVal = left.__proto__;
  const rightVal = right.prototype;
  //若找不到就一直循环到父类型或祖类型
  while(leftVal){
    console.log(leftVal)
    if(leftVal === rightVal){
      return true;
    }
    leftVal = leftVal.__proto__;//获取祖类型的__proto__
  }
  return false;
}

let arr = [1,2];
console.log( myInstanceof(arr,Array) );
```

### 1.3.3 constructor

任何一个对象都有constructor属性，指向创建这个对象的构造函数。可以判断变量对象具体是哪种数据类型。

- 注意：null和undefined是无效的对象，所以没有constructor的存在

```js
null.constructor === Null 				// Cannot read property 'constructor' of null    // 注意点
undefined.constructor === Undefined		// Cannot read property 'constructor' of null    // 注意点
(1).constructor === Number  			// true
'123'.constructor == String 			// true
true.constructor == Boolean 			// true
Symbol().constructor == Symbol 			// true

(function(){}).constructor === Function // true
[].constructor === Array				// true
({}).constructor === Object				// true
```

### 1.3.4 Object.prototype.toString.call()/apply()/bind()

```js
// Object.prototype.toString
Object.prototype.toString()  // 返回的都是[object Object]

// Object.prototype.toString.call
Object.prototype.toString.call(1)         // [object Number]
Object.prototype.toString.call("123")     // [object String]
Object.prototype.toString.call(true)	  // [object Boolean]
Object.prototype.toString.call(null)      // [object Null]
Object.prototype.toString.call(undefined) // [object Undefined]
Object.prototype.toString.call(Symbol())  // [object Symbol]

Object.prototype.toString.call(Functon)   // [object Function]
Object.prototype.toString.call(Array)	  // [object Function]    // 注意点
Object.prototype.toString.call(Object)	  // [object Function]    // 注意点
```

**原因：**对象类型的toString()方法返回的是`[object Object]`，所有的内置构造函数都是继承自`Object.prototye`，可以利用`call()`，`apply()`，`bind()`函数来改变`Object.prototype.toString()`的执行上下文

**不能判断是不是null和undefined类型**

​	constructor，因为在constructor中null和undefined是无效对象

​	instanceof，因为instanceof只能用来判断是不是对象或者函数，不能用来判断字符串和数字等

**可以判断是不是null和undefined类型**

​	typeof: typeof null 返回的是object，typeof undefined 返回的是undefined

​	Object.prototype.toString.call() 返回对象的类型

## 1.4 等号判断 ==

**`==`判断步骤：**

1. 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值：false转换为0，而true转换为1。
2. 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值。
3. 如果一个操作数是对象，另一个操作数不是，则调用对象的`valueOf()`方法，如果得到的值不是基本类型值，则基于返回值再调用toString方法（这个过程即ToPrimitive），用得到的基本类型值按照前面的规则进行比较。
4. 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数指向同一个对象，则相等操作符返回true, 否则返回false。

**`==`规则：**

- null 和 undefined 是相等的。
- 要比较相等性之前，不能将null和undefined转换成其他任何值
- 如果有一个操作数是NaN，则相等操作符返回false, 而不相等操作符则返回true, NaN != NaN

![preview](https://segmentfault.com/img/remote/1460000008594795?w=832&h=397/view)

**具体案例：**

```js
undefined == null 
undefined === null
1==='1'
[] instanceof Array// true
// true,false,false,true

[] == ![] 
!![]
!!''
// 右侧："!"运算符的优先级大于"=="，会将后面的值转化为布尔值即!Boolean([])=!true=false=0，
// 左侧：[]=ToPrimitive([])=""=Number("")=0
// true,true,false

isNaN("100")
parseInt("1a") === 1 
// false,true
```

## 1.5 计算机制（0.1+0.2>0.3）

>0.1+0.2=0.30000000000000004
>0.1+0.7=0.7999999999999999

- 原因：像0.1这样的数值用**二进制表示**你就会发现无法整除，最后算下来会是 0.000110011....由于**存储空间有限，最后计算机会舍弃后面的数值**，所以我们最后就只能得到一个近似值。
- 解决：将浮点数转化成整数计算。（比如先乘10再除以10）

# 2. 数组

## 2.1 数组类型判断

```js
var result = [1,2]
result instanceof Array
Array.isArray(result)
result.constructor === Array
// 确定对象之间是否存在这种关系
Array.prototype.isPrototypeOf(result)
// 原型上的toString可以输出类型，一般实例中的toString被重写
Object.prototype.toString.call(result) === "[object Array]"
```

**数组为空：**

```js
if (matrix == null || matrix.length == 0) return true;
```

## 2.2 数组的方法

|     方法      | 描述                                                         |
| :-----------: | :----------------------------------------------------------- |
|    join()     | 把数组转换成字符串。默认是逗号，                             |
|    push()     | 把里面的内容添加到数组末尾，并**返回修改后的长度**。**（会改变原数组）** |
|     pop()     | 移除数组最后一项，返回移除的那个值。**（会改变原数组）**     |
|    shift()    | 删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。**（会改变原数组）** |
|   unshift()   | 将参数添加到原数组开头，并返回数组的长度 。**（会改变原数组）** |
|    sort()     | 函数参数如果不设置的话，会以默认方式（字母顺序 / unicode字符编码的顺序）进行排序。**（会改变原数组）** |
|   reverse()   | 反转数组项的顺序。**（会改变原数组）**                       |
|   concat()    | 将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本 |
|    slice()    | 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。参数：arrayObj ，start，end可选项。 |
|   splice()    | 删除、插入和替换。3 个参数：起始位置， 要删除的项数（0就是不删除），插入的项。；返回删掉的数据**（会改变原数组）** |
|   reduce()    | （ES5新增）对一个数组进行遍历，然后返回一个累计              |
|   indexOf()   | （ES5新增）接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的开头 0 开始向后查找。 |
| lastIndexOf() | （ES5新增）接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始向前查找。 |
|   forEach()   | （ES5新增）对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；对应的数组索引，数组本身。 |
|     map()     | （ES5新增）指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的**数组**。 |
|   filter()    | （ES5新增）“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 |
|    every()    | （ES5新增）判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 |
|    some()     | （ES5新增）判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 |
|    flat()     | （ES6新增）用于将嵌套的数组“拉平”，变成一维数组，参数是拉多少层；如果有空位flat()会跳过 |
|   flatMap()   | （ES6新增）执行Array.prototype.map()，然后执行flat()方法。flatMap()只能展开一层数组 |
| copyWithin()  | （ES6新增）在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。**（会改变原数组）** |
|    fill()     | （ES6新增）将一个固定值替换数组的元素。**（会改变原数组）**  |

**splice()：** 3 个参数：起始位置， 要删除的项数（0就是不删除），插入的项。；返回删掉的数据

```js
a=[1,2,3,4,5,6,7]
console.log(a.splice(2, 4)) 		// [3,4,5,6] 删除操作
console.log(a) 						// [1,2,7]
console.log(a.splice(1, 1, [8, 9])) // [2]		 替换操作	 
console.log(a) 						// [1,[8, 9],7]
console.log(a.splice(1, 0, 3)) 		// []		 添加操作
console.log(a) 						// [1,3,[8, 9],7]
```

### （1）姓名排序

**localeCompare()：**把当前的汉字转化为拼音，再根据首字母进行排序。（拼音 > unicode）

方法2：重新写一个数组用来存“赵钱孙李”，然后判断姓名的第一个字在那个里面的顺序

```js
['李晓明','王晓璐','张一丹','白小马','阿凡提'].sort(function(a,b){return a.localeCompare(b)}  // 姓名排序
```

### （2）按对象中某属性排序

```js
var arr = [
    {name:'zopp',age:0},
    {name:'gpp',age:18},
    {name:'yjj',age:8}
];
function compare(property){
    return function(a,b){
        var value1 = a[property];
        var value2 = b[property];
        return value1 - value2;
    }
}
console.log(arr.sort(compare('age')))
```

### （3）Array.reduce()实现

> reduce 函数可以对一个数组进行遍历，然后返回一个累计

reduce 接受的**第二个参数**是一个初始值，它是可选的。

- 如果我们传递了初始值，那么它会作为 acc 传递给第一个 callback，此时 callback 的第二个参数 val 是数组的第一项
- 如果我们没有传递初始值给 reduce，那么数组的第一项会作为累计值传递给 callback，数组的第二项会作为当前项传递给 callback。

```js
// reduce 的两个参数：
@param {Function} callback 迭代数组时，求累计值的回调函数
@param {Any} initVal 初始值，可选

// 第一个参数：callback 函数可以接受四个参数：
@param {Any} acc 累计值
@param {Any} val 当前遍历的值
@param {Number} key 当前遍历值的索引
@param {Array} arr 当前遍历的数组
```

```js
Array.prototype.myReduce = function(fn, prev){
    for (let i = 0; i < this.length; i++){
        if(typeof prev === 'undefined'){
        	prev = fn(this[i], this[i+1], i++, this);
        } else {
        	prev = fn(prev, this[i], i, this);
        }
    }
	return prev;
}
```

## 2.3 深浅拷贝

> **赋值：**JS中的数组是引用类型，不能直接赋值，赋得的是引用（栈中的地址）。

> **浅拷贝：**不可以拷贝对象里的子对象。

> **深拷贝：**可以拷贝对象里的子对象。

![](https://i.loli.net/2020/07/02/limKsPASbnCBMg8.png#alt=image-20200619162012701)

### 2.3.1 浅拷贝

- `Array.prototype.concat()`

- `Array.prototype.slice()`

- 库函数`lodash.clone()`

- `Object.assign()`

  把任意多个的源对象自身的**可枚举属性**拷贝给目标对象，然后返回目标对象。

- 展开运算符`...`

```js
obj2 = obj1.concat();
obj2 = obj1.slice();
obj2 = _.clone(obj1);  // var _ = require('lodash');
obj2 = Object.assign({}, obj1);
obj2 = {... obj1};
```

### 2.3.2 深拷贝

- `JSON.stringify`和`JSON.parse`
- `lodash.cloneDeep`
- `jQuery.extend()`
- for循环拷贝，为避免循环引用可以使用hashMap

**1）`JSON.stringify`和`JSON.parse`实现深拷贝**

JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象

```js
let newList = JSON.parse(JSON.stringify(this.List))
```

**局限性：**

   - 会忽略 `undefined`、 `symbol`
   - 只能序列化属性，不能序列化函数方法
   - 不能解决循环引用的对象

**2）库函数lodash.cloneDeep**

该函数库也有提供_.cloneDeep用来做 Deep Copy

```javascript
var _ = require('lodash');
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**3）jQuery.extend()方法**

```js
var $ = require('jquery');
var obj2 = $.extend(true, {}, obj1); // 第一个参数为true,就是深拷贝
```

**4）for循环拷贝**

**（1）深拷贝递归实现**

**原理：**递归遍历对象、数组**直到里边都是基本数据类型**，然后再去复制，就是深度拷贝

```javascript
// 简单版本
function deepCopy(obj) {
    if (typeof obj !== 'object') return
    let newObj = obj instanceof Array ? [] : {}
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) { // 属性在实例中而非原型对象中
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                newObj[key] = deepCopy(obj[key])
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    return newObj
}
```

**缺点：**存在循环引用：`obj.value = obj`。

**改进：**用**Map**设置一个哈希表存储已经拷贝过的对象，当检测到当前对象已存在于哈希表时，取出该值返回。

```javascript
// 利用Map来检测当前对象是否已拷贝，若已拷贝，则直接取出
// 如果利用weakMap的话，可以利用垃圾回收机制回收内存
function deepCopy(obj, map = new Map()) {
    if (typeof obj !== 'object') return
    let newObj = Array.isArray(obj) ? [] : {}
    if (map.get(obj)) {  // 如果对象曾经有过，就不用再深入循环拷贝了，返回
        return map.get(obj)
    }
    map.set(obj, newObj) // 以对象为key，newObj是value
    for (let key in obj) {  // 遍历原型对象和实例中的属性
        if (obj.hasOwnProperty(key)) {	// 只需要深拷贝实例中的属性，原型上的属性在对象创建时就有
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                newObj[key] = deepCopy(obj[key], map)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    return newObj
}
```

**（2）深拷贝非递归实现**

```javascript
// 主要是用到了Object对象的一些方法
function deepCopy(obj) {
    console.log('是非递归实现的')
    let newObj = {}
    let properties =Object.getOwnPropertyNames(obj);
    for (let pro of properties) {
        descri = Object.getOwnPropertyDescriptor(obj, pro);
        Object.defineProperty(newObj, pro, descri)
    }
    return newObj
}
```

## 2.4 类数组

- 类数组是一个普通对象，数组类型是Array
- 类数组不具备数组的方法(splice，split，push..)

![image-20200802203923222](E:\Cloud\工作\前端之路\前端笔记\fig\image-20200802203923222.png)![image-20200802204028318](E:\Cloud\工作\前端之路\前端笔记\fig\image-20200802204028318.png)

**类数组转化为数组：**

```js
Array.prototype.slice.call(arguments)
Array.prototype.slice.apply(arguments)
[].slice.call(arguments)
[].concat.apply([],arguments)
Array.from(arguments) // es6
[...arguments]	      // es6
```

```js
var toArray = function(s){  
   try {  
       return Array.prototype.slice.call(s);  
   } catch(e){  
       var arr = [];  
       for(var i = 0,len = s.length; i < len; i++){  
          //arr.push(s[i]);  
          arr[i] = s[i];     //据说这样比push快
       }  
       return arr;  
    } 
}
```

## 2.5 数组合并

- **concat()**
- **Array.prototype.push.apply() / call()：**
- **for循环**

```js
var c = a.concat(b); 	// c = [1,2,3,4,5,6];
Array.prototype.push.apply(a, [4,5,6]) 	// a = [1,2,3,4,5,6];
```

## 2.6 数组遍历

- **for循环**
- **forEach：**`arr.forEach((item, index) =>{})`
- **map函数：**遍历数组每个元素，并回调操作，需要返回值，返回值组成新的数组，原数组不变
- **filter函数：**过滤通过条件的元素组成一个新数组， 原数组不变
- **some函数：**遍历数组中是否有符合条件的元素，返回Boolean值
- **every函数：**遍历数组中是否每个元素都符合条件， 返回Boolean值
- **in：** 不仅可以用来 遍历对象，还可以用来遍历数组， 不过 i 对应与数组的 key值

## 2.7 算法

### 2.7.1 数组去重

**1）HashMap**

```js
function method(arr) {
   let res = []
   let tmp = []
   for(let item of arr) {
       if(!tmp[item]) {
           tmp[item] = 1
           res.push(item)
       }
   }
   return res
}
```

**2）filter（ES5）**

```js
function method(arr) {
    return arr.filter((value, index, self) => {
        return self.indexOf(value) === index
    })
}
```

**3）Set（ES6）**

Set不会改变初始插入顺序

```js
function method(arr) {
	let res = new Set()
    let res = []
    for(let item of arr){
        if(!res.has(item)){
            result.push(item) 
            res.add(item)
        }
    }
    return res
}
```

**4）Array to Set, and Set to Array（ES6）**

```js
function method(arr) {
	return Array.from(new Set(arr))
    // return [...new Set(arr)]
}
```

### 2.7.2 数组扁平化Array.flat()

```js
let arr1 = [1,2,['a','b',['中','文',[1,2,3,[11,21,31]]]],3];
console.log(arr1.flat(Infinity));  // 参数是拉平多少层，1就是拉平一层（ES6）
```

**1）reduce**

原理：reduce接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

参数：回调函数，传给result的初始值

```js
function flatten(arr) {  
    return arr.reduce((result, item)=> {
        return result.concat(Array.isArray(item) ? flatten(item) : item);
    }, []);
}
```

**2） 扩展运算符**

原理：利用Array.some方法判断数组中是否还存在数组，es6扩展运算符能将二维数组变为一维

```js
function method(arr) {
    while (arr.some(item => Array.isArray(item))) { // 若arr中含有数组则使用一次扩展运算符，直至没有为止。
        arr = [].concat(...arr);  // 每次循环都扁平化一层，扩展运算符能将二维数组变为一维
    }
    return arr;
}
console.log(method(arr1));
```

**3）toString & split | join & split**

原理：将数组变为字符串然后再用split分割还原为数组

`Array.map`：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。

```js
function flatten(arr) {
    return arr.toString().split(',').map(function(item) {
        return Number(item);
    })
} 
function flatten(arr) {	// 和上面的toString一样，join也可以将数组转换为字符串
    return arr.join(',').split(',').map(function(item) {
        return parseInt(item);
    })
}
```

**4）递归**，时间和空间上过慢

```js
function flatten(arr) {
    var res = [];
    arr.map(item => {
        if(Array.isArray(item)) {
            res = res.concat(flatten(item));
        } else {
            res.push(item);
        }
    });
    return res;
}

```

### 2.7.3 数组乱序

1）`sort()`实现数组乱序：

```js
arr.sort(() => Math.random() - 0.5);
```

但是，这种写法是有问题的，它并不能真正地随机打乱数组，执行多次后，每个元素仍然有很大机率在它原来的位置附近出现。

2）`Math.random()`随机获取 [0,1) 之间的数，`Math.random()*2+1`随机获取 [1,3) 之间的数。结果可能是浮点数。

```js
function method(arr){
    let res = []
    let len = arr.length
    while(len){
        let index = Math.floor(Math.random()*len--)
        res.push(arr[index])
        arr.splice(index,1)
    }
    return res
}
console.log(method([1,2,3,4,5]))
```

```js
// 只需交换位置，无需对数组进行修改或增加新数组。
function shuffle(arr) {
    let i = arr.length;
    while (i) {
        let j = Math.floor(Math.random() * i--);
        [arr[j], arr[i]] = [arr[i], arr[j]];
    }
}
```

### 2.7.4 url解析成对象

```js
const parseQueryString = function(url){
     var obj = {};
     var arr = url.substr(url.indexOf('?') + 1).split('&');
     arr.forEach(item => {
         let tmp = item.split('=');
         obj[tmp[0]] = tmp[1];
     });
     return obj;
}
```

## 2.8 数组和链表的区别

| 数组                                                         | 链表                                                     |
| ------------------------------------------------------------ | -------------------------------------------------------- |
| 连续的地址空间                                               | 不一定是连续的                                           |
| 内存管理会将连续的存储空间提前读入缓存，数组会被读入到缓存，随机访问效率很高 | 不能随机查找，必须从第一个开始遍历，查找效率低（改查慢） |
| 插入和删除效率低                                             | 插入删除速度快（增删快）                                 |
| 数组大小固定，不能动态拓展                                   | 大小没有固定，可以动态拓展                               |
| 内存空间要求高，必须有足够的连续内存空间                     | 内存利用率高，不会浪费内存                               |

# 3. 对象

### 全局对象

- **global对象：**全局对象

- **window对象：**在浏览器中的全局对象。

  - 在全局作用域中声明的变量、函数都是window对象的属性和方法。this指向全局对象。

  - `window.location`是一个对象，指当前文档，可以用其它文档取代当前文档（可以改变）；

- **document对象：**window对象的一个属性，是显示于窗口内的一个文档。
  - ` document.location`不是对象，是指当前显示文档的位置（用户不能改变）。

[global对象、window对象、document对象概念]: https://blog.csdn.net/chenchunlin526/article/details/78908592

### 对象类型判断

```js
var result ={}
typeof result === 'object' // 可能是null、[]、Array等
result instanceof Object
result.constructor === Object
Object.prototype.isPrototypeOf(result)
Object.prototype.toString.call(result) === "[object Object]"
$.isPlainObject(result)
```

### 判断对象为空

- `for...in...` 遍历属性，进入for循环就是true
- `JSON.stringify(obj) === '{}'`
- `Object.keys(obj).length === 0` / `Object.values` / `Object.entries`
- `Object.getOwnPropertyNames().length === 0`

### 判断是否包含某个属性

- **indexOf：**`obj.indexOf("name")`
- **in：**`"name" in obj`
- **hasOwnProperty：**`obj.hasOwnProperty("name")`

### 判断对象是否相等



## 3.0 对象生成

- 字面量`var obj = {}`和`new`关键字创建的对象是`Object`的实例，__proto__指向`Object.prototype`，继承内置对象`Object`
- `Object.create(arg, pro)`创建的对象的原型取决于`arg`，`arg`为`null`，新对象是空对象，没有原型，不继承任何对象；`arg`为指定对象，新对象的__proto__指向指定对象`arg`，继承指定对象

### 3.0.1 new的过程

1. 创建一个空对象 obj；
2. 将新创建的空对象的__proto__指向其构造函数的prototype对象；
3. 使用 apply 改变 this 的指向，将this指向执行新实例对象obj，并执行构造函数把结果赋值给result；
4. 返回新对象

```js
function New(fn){
    // 1. 新建一个空对象obj
    var obj = {};
    var args = [...arguments].slice(1); // 类数组转换成数组然后取非函数值。
    // 2. obj的__proto__指向其构造函数的原型对象
    obj.__proto__ = fn.prototype;
    // 3. obj执行执行构造函数，返回结果
    var result = fn.apply(obj, args);
    // 4. 返回对象
    // 构造函数F的执行结果是引用类型，就把这个引用类型的对象返回
    // 构造函数F的执行结果是值类型，就返回obj空对象
     return typeof(result) === 'object' ? result : obj;
    //return Object.prototype.toString.call(result) =='[object Object]'? result:obj
}

// 构造函数模式，没有return值
function Fun1(arg1, arg2){
    this.name = arg1;
    this.age = arg2;
}
// 寄生构造函数模式，（和工厂模式是一样的），这里会返回一个新的对象
function Fun2(arg1, arg2){
    var o = new Object();
    o.name = arg1;
    o.age = arg2;
    return o
}
```

### 3.0.2 Object.Create()

`Object.create(proto, [propertiesObject])` ----- 原型式继承

- `proto`必填参数，是新对象的原型对象，如上面代码里新对象`me`的`__proto__`指向`person`。注意，如果这个参数是`null`，那新对象就彻彻底底是个空对象，没有继承`Object.prototype`上的任何属性和方法，如`hasOwnProperty()、toString()`等。
- `propertiesObject`是可选参数，指定**要添加到新对象上的可枚举的属性**（即其自定义的属性和方法，可用`hasOwnProperty()`获取的，而不是原型对象上的）的描述符及相应的属性名称。

**规则：**`Object.create(arg, pro)`创建的对象的原型取决于`arg`

- `arg`为`null`，新对象是空对象，没有原型，不继承任何对象；
- `arg`为指定对象，新对象的__proto__指向指定对象`arg`，继承指定对象。

```js
Object.mycreate = function(proto, properties) {
    function F() {};
    F.prototype = proto;
    if(properties) {
        Object.defineProperties(F, properties);
    }
    return new F();
}
var obj = {a: 11}
var o = Object.mycreate(obj, {mm: {value: 10}});
console.dir(o);
console.log(o.__proto__ === Object.protorype); // false
console.log(o.__proto__ === obj); // true
```

[Object.create()、new Object()和{}的区别]: https://juejin.im/post/6844903917835436045

## 3.1 对象的属性

注意：一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用Object.defineProperty()方法修改除 writable 之外的特性，都会导致错误。

### 3.1.1 数据属性

数据属性包含一个**数据值的位置**。在这个位置可以读取和写入值。有 4 个描述其行为的特性。

- **[[Configurable]]：**表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。直接在对象上定义的属性，该特性默认值为 true。
-  **[[Enumerable]]：**表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，该特性默认值为 true。
-  **[[Writable]]：**表示能否修改属性的值。直接在对象上定义的属性，该特性默认值为 true。
-  **[[Value]]：**包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。

### 3.1.2 访问器属性

访问器属性不包含数据值；它们包含一对 **getter 和 setter** 函数（不过，这两个函数都不是必需的）。访问器属性不能直接定义，必须使用 Object.defineProperty()来定义

- **[[Configurable]]：**表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。直接在对象上定义的属性，该特性默认值为 true。
-  **[[Enumerable]]：**表示能否通过 for-in 循环返回属性。直接在对象上定义的属性，该特性默认值为 true。
-  **[[Get]]：**在读取属性时调用的函数。默认值为 undefined。
-  **[[Set]]：**在写入属性时调用的函数。默认值为 undefined。

### 3.1.3 Object.defineProperty()

==`Object.defineProperty()`方法：==接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（ descriptor）对象的属性必须是： configurable、 enumerable、 writable 和 value。设置其中的一或多个值，可以修改对应的特性值。例如：

```js
var person = {};
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas"
});
alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
```

**在调用 Object.defineProperty()方法时，如果不指定， configurable、 enumerable 和writable 特性的默认值都是 false。**

==`Object.defineProperties()`方法：==一次定义多个属性

==`Object.getOwnPropertyDescriptor()`方法：==读取属性的特性

**缺点：**

- 无法监听数组变化
- 只能劫持对象的属性

## 3.2 创建对象

 Object 构造函数（new对象然后用点赋值法）或对象字面量（花括号中直接设置属性和方法）都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生**大量的重复代码**。

### 1）工厂模式

**工厂模式解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）**

```js
function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };
    return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
```

### 2）构造函数模式

优点：明确对象的类型。

缺点：每个方法都要在每个实例上重新创建一遍。

```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
```

### 3）原型模式

函数的 prototype（原型）属性是一个指针，指向一个对象，其中包含了可以由特定类型的所有实例共享的属性和方法。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
person1.sayName(); //"Nicholas"
var person2 = new Person();
person2.sayName(); //"Nicholas"
alert(person1.sayName == person2.sayName); //true
```

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595679055643.png" alt="img" style="zoom:80%;" />

==`isPrototypeOf()`方法：==确定对象之间是否存在这种关系。

==`Object.getPrototypeOf()`方法：==（ES5）返回`[[Prototype]]`的值。

==`hasOwnProperty()`方法：==可以检测一个属性是存在于实例中，还是存在于原型中，来自实例返回 true。

==`in` 操作符：==会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。 

==`for-in` 循环：==返回所有能通过对象访问的、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中的属性。

==`Object.keys()`方法：==取得对象上所有可枚举的实例属性

==`Object.getOwnPropertyNames()`方法：==得到所有实例属性，无论它是否可枚举

```js
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true

alert(Object.getPrototypeOf(person1) == Person.prototype); //true
alert(Object.getPrototypeOf(person1).name); //"Nicholas"

alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true

console.log(Object.keys(Person.prototype)) 	//"name,age,job,sayName"
console.log(Object.getOwnPropertyNames(Person.prototype)) //"constructor,name,age,job,sayName"
```

**注意1：实例中的指针仅指向原型，而不指向构造函数。**

**注意2：可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。**如果我们在实例中添加了一个与实例原型中的一个属性同名的属性，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。另外，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

**注意3：使用`Person.prototype = {}` 后constructor 属性不再指向 Person。**本质上完全重写了默认的 prototype 对象。可以在定义时重新设置一下`Person.prototype = { constructor : Person }`

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595680381476.png" alt="img" style="zoom:80%;" />

原型模式的最大问题是由其共享的本性所导致的。对于包含引用类型值的属性（如，共享数组）来说，问题就比较突出了。

### 4）组合构造函数和原型模式

**构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。**

```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["Shelby", "Court"];
}
Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
person1.friends.push("Van");
alert(person1.friends); //"Shelby,Count,Van"
alert(person2.friends); //"Shelby,Count"
alert(person1.friends === person2.friends); //false
alert(person1.sayName === person2.sayName); //true
```

### 5）动态原型模式

它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以**通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。**

```js
function Person(name, age, job){
    //属性
    this.name = name;
    this.age = age;
    this.job = job;
    //方法：这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。
    if (typeof this.sayName != "function"){
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();
```

### 6）寄生构造模式

通常，在前述的几种模式都不适用的情况下，可以使用寄生构造模式。

创建一个构造函数，该函数的作用仅仅是封装创建函数的代码，使用new操作符创建对象。

```javascript
function CO(...){
	var o = new Object();
	o.propertyName = “...";
	o.funcName = function(){...};
	return o;
}
var obj = new CO(...);
```

**应用场景：**创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。

```js
function SpecialArray(){
    var values = new Array(); //创建数组
    values.push.apply(values, arguments);//添加值
    values.toPipedString = function(){//添加方法
        return this.join("|");
    };
    return values;//返回数组
}
var colors = new SpecialArray("red", "blue", "green");
alert(colors.toPipedString()); //"red|blue|green"
```

缺点：不能确定对象实例的具体类型

### 7）稳妥构造模式

稳妥对象指的是没有公共属性，其方法也不引用this的对象，不能使用 new 操作符调用构造函数。

应用场景：

- 在一些安全的环境中（这些环境中会禁止使用 this 和 new）；
- 在防止数据被其他应用程序（如 Mashup程序）改动时使用。

```javascript
function CO(...){
	var o = new Object();
	//可以在这里定义私有变量和函数
	...
	//添加方法
	o.funcName = function(){
	//操作变量
	};
	return o;
}
var obj = CO(...);
// 除了调用方法外，没有别的方式可以访问其数据成员。
```

## 3.3 原型

函数的 prototype（原型）属性是一个指针，指向一个对象，其中**包含了可以由特定类型的所有实例共享的属性和方法**。

主要是为了解决创建对象时出现的代码复用问题，大大减少内存消耗。

## 3.4 原型链

**每个对象（除null）都有 `__proto__` 属性**，这个属性指向了创建该对象的构造函数的原型。而原型对象也通过`__proto__`指向它自己的原型对象，层层向上直到Object.prototype，这样就形成了原型链。

**原型链的特点：**

- 当访问对象属性时，如果对象内部没有这个属性，就会沿着原型链一直往上找；

- 当修改原型时，与之相关的对象也会继承这一改变

**原型链的缺点：**

- 如果被继承的实例中包含引用类型属性，那么新生成的子类实例，如果对引用类型的属性进行修改，那么其他实例的该属性也会发生变化。

- 不能向超类的构造函数中添加参数

## 3.5 继承

子类的原型作为父类的实例，子类的实例共享父类原型的所有属性和方法。

```js
function SuperType(){
    this.property = true;
}
SuperType.prototype.getSuperValue = function(){
    return this.property;
};
function SubType(){
    this.subproperty = false;
}
SubType.prototype = new SuperType(); //继承了 SuperType
SubType.prototype.getSubValue = function (){
    return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
```

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595681408705.png" alt="img" style="zoom:80%;" />

instance 指向 SubType的 原 型 ， SubType 的 原 型 又 指 向 SuperType 的 原 型 。 getSuperValue() 方 法 仍 然 还 在SuperType.prototype 中，但**property 则位于 SubType.prototype 中**。这是因为 property 是一个实例属性，而 getSuperValue()则是一个原型方法。既然 SubType.prototype 现在是SuperType的实例，那么 property 当然就位于该实例中了。此外，要注意 **instance.constructor 现在指向的是 SuperType**，这是因为原来 SubType.prototype 中的 constructor 被重写了的缘故（实际上，不是 SubType 的原型的 constructor 属性被重写了，而是 SubType 的原型指向了另一个对象——SuperType 的原型，而这个原型对象的 constructor 属性指向的是 SuperType。）。

**自定义类型和Object、Function的区别：**

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\image-20200726112414510.png" alt="image-20200726112414510" style="zoom: 60%;" />

1. js分为**函数对**象和**普通对象**，每个对象都有__proto__属性，但是**只有函数对象才有prototype属性**

2. Object、Function都是js内置的**函数**，类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String
3. 属性__proto__是一个对象，它有两个属性，constructor和__proto__；
4. 原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建；
5. **准则1：**原型对象（即Person.prototype）的constructor指向构造函数本身
6. **准则2：**实例（即person01）的__proto__和原型对象指向同一个地方

```
Person.prototype.constructor == Person
person01.__proto__ == Person.prototype
```

![](https://user-gold-cdn.xitu.io/2019/11/6/16e3fec6c1fb209e?imageslim)

[轻松理解JS 原型原型链]: https://juejin.im/post/5dc26f55e51d456e35627301

### 3.5.1 继承方式

#### 1）原型链

将父类的实例作为子类的原型，子类的实例共享Super实例的所有属性和方法

```javascript
function Super(){...} // 父类
Super.prototype.propertyName = ....;

function Sub(){...}  // 子类
Sub.prototype = new Super(); //将父类的实例赋给子类的原型
Sub.prototype.propertyName = ....;
```

**缺点：**

- 如果被继承的实例中包含引用类型属性，那么新生成的子类实例，如果对引用类型的属性进行修改，那么其他实例的该属性也会发生变化。
- 在创建子类型的实例时，不能向超类的构造函数中传递参数。

#### 2）借用构造函数

在子类的内部调用父类的构造函数

```javascript
function SuperType(name){
	this.name = name;
}
function SubType(){
	SuperType.call(this);
    //  SuperType.call(this, "Nicholas"); //继承了 SuperType，同时还传递了参数
    this.age = 29;	//实例属性
}
var instance = new SubType();
alert(instance.name); //"Nicholas";
alert(instance.age); //29
```

**优点：**可以在子类型构造函数中向超类型构造函数传递参数

**缺点：**方法都在构造函数中，无法复用

#### 3）组合继承

使用原型链实现对原型属性和方法的继承，而借用构造函数来实现对实例属性的继承

```javascript
function SuperType(name){
	this.name = name;
	this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function(){...};
function SubType(name,age){
	SuperType.call(this,name);
	this.age = age;
}
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){...};

//具体使用
var instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
alert(instance1.colors); //"red,blue,green,black"
instance1.sayName(); //"Nicholas";
instance1.sayAge(); //29
var instance2 = new SubType("Greg", 27);
alert(instance2.colors); //"red,blue,green"
instance2.sayName(); //"Greg";
instance2.sayAge(); //27
```

**优点：**sub实例即分别拥有自己的属性，又可以使用相同的方法，并且可以向父类的构造函数传递参数。

**缺点：**调用了两次父类的构造函数

#### 4）原型式继承

基于已有的对象创建新对象，同时还不必因此创建自定义类型。

```js
var o = {...};
function obj(o){
	function F(){}
	F.prototype = o; // 将传入的对象作为这个构造函数的原型
	return new F();  // 最后返回了这个临时类型的一个新实例
}
var no = obj(o);
```

ES5新增Object.create()方法规范原型式继承，如下：

**规则：**`Object.create(arg, pro)`创建的对象的原型取决于`arg`

- `arg`为`null`，新对象是空对象，没有原型，不继承任何对象；
- `arg`为指定对象，新对象的__proto__指向指定对象`arg`，继承指定对象。

```javascript
var no = Object.create(o);     // 等同于obj(o);
var no = Object.create(o，{
	name:{value:"..."}
}); 		// 创建新对象并覆盖原型对象上的同名属性
```

**优点（应用场景）：**在没有必要创建构造函数，只想让一个对象与另一个对象保持类似的情况下。

**缺点：**包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。

#### 5）寄生式继承

在构造函数内部增强对象

```javascript
function createAnother(o){
	var clone = Object.create(o);   // 通过调用函数创建一个新对象，使新对象的原型指向传入的对象
	clone.sayHi = function(){...};  // 以某种方式来增强这个对象
	return clone;  // 返回这个对象
}
```

**优点（应用场景）：**主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。

**缺点：**使用寄生式继承来为对象添加函数，会由于**不能做到函数复用**而降低效率；这一点与构造函数模式类似。

#### 6）寄生组合式继承

**背景：**组合继承需要调用两次父类的构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。导致在调用子类型构造函数时重写继承的属性。

**寄生组合式继承：**可以通过借用构造函数来继承属性，通过原型链混成的形式来继承方法。

- **不用为了指定子类型的原型而调用超类型的构造函数，只需要超类型原型的一个副本。**

```javascript
function inheritPrototype(SubType,SuperType){
	var prototype = Object.create(SuperType.prototype);  // 创建超类型原型的副本
	prototype.constructor = SubType;  // 为创建的副本添加constructor属性，弥补因重写原型失去的默认constructor属性
	SubType.prototype = prototype;  // 将副本赋值给子类型的原型
}
— — — — — — — — — — — — — — — — — — — —
function SuperType(name){
	this.name = name;
	this.colors = ["red"];
}
SuperType.prototype.sayName = function(){alert(this.name);};
function SubType(name,age){
	SuperType.call(this,name);
	this.age = age;
}
inheritPrototype(SubType,SuperType);
SubType.prototype.sayAge = function(){alert(this.age);};
```

**优势：**

- 只调用了一次父类构造函数
- 并且避免了在SubType.prototype上面创建不必要的多余的属性

### 3.5.2 具体应用

1）补充完整方法，使结果正确输出

```js
let a=[1,2,3];
a.mutiply();
console.log(a);//1,4,9

// 具体修改如下：
Array.prototype.mutiply = function(){
    for(let i=0; i<this.length; i++){
        this[i] = this[i] * this[i]
    }
    return this
}
```

# 4. 函数

**定义函数的方法**

1）函数声明：具有函数声明提升特征（可以把函数声明放在调用它的语句后面）

2）函数表达式：可以使用匿名函数（拉姆达函数）；可以通过条件判断定义函数表达式的不同逻辑

## 4.1 apply、call、bind

`apply()`和`call()`都是在特定的作用域中调用函数，**用于扩充函数赖以运行的作用域**。区别仅在于传入参数的形式的不同。

- `apply()` 第一个参数是对象，第二个参数是参数数组；
- `call()` 第一个参数是对象，其余参数必须逐个列举出来；
- `bind()` 通过传入一个对象，返回这个对象绑定的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

**call 方法比 apply 快的原因：**call 方法的参数格式正是内部方法所需要的格式。

**函数bind两次后this指向：**在第一次bind完this就已经确定了，结果返回一个函数，这个函数体内不存在this问题，后续无论bind多少次，this都指向第一次bind传入的context，但是后面bind再传入的参数会生效。（类似柯里化过程）

**apply实现**

```js
// this是调用的函数对象
// context是使用对象
Function.prototype.myApply = function(context){
    var context = context || window, result;
    context.fn = this;
    if(arguments[1]){
        result = context.fn(...arguments[1])
    } else {
        result = context.fn();
    }
    delete context.fn
    return result
}
```

**call实现**

```js
Function.prototype.myCall = function (context) {
    var context = context || window, result;
    context.fn = this;
    var args = [...arguments].slice(1);
    if(args.length>=1) {
        result = context.fn(...args)
    }else {
        result = context.fn()
    }
    delete context.fn
    return result;
}
```

**bind实现**

```js
 Function.prototype.myBind = function (context) {
     var context = context || window;
     // 保存此时的this，不能和return的function中的this混淆
     var _this = this;		
     var args = [...arguments].slice(1);
     return function () {
         // 把第二次的参数也一起加入到总的参数数组中，考虑到柯里化
         args.push(...arguments);
         return _this.apply(context, args);
         // return _this.call(context, ...args, ...arguments);
     }
 }
```

## 4.2 闭包

**闭包是指有权访问另一个函数作用域中的变量的函数。**创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

**作用域链：**保证对执行环境有权访问的所有变量和函数的有序访问。本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。

### 4.2.1 闭包的优点（用途）

- 在函数外部能够访问到函数内部的变量。
- 被闭包引用的变量对象在程序结束后可以继续留在内存中，实现变量数据共享。**（缺陷，内存泄露）**
- 利于代码封装，访问私有变量，方便调用上下文的局部变量。**（缺陷，不要随便改变父函数内部变量的值）**

### 4.2.2 闭包的缺陷

- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

- 闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。

  解决方法是，在退出函数之前，将不使用的局部变量全部删除。

  ```
  删除对象的属性       delete obj.name;
  删除其他	        str = undefined;
  删除不了原型链中的变量
  ```

### 4.2.3 闭包的应用场景

- setTimeout，闭包可以实现setTimeout传参效果
- 对DOM事件绑定，设置回调函数
- 函数防抖，触发事件n秒后再执行回调，如果在n秒内再次被触发，则重新计时。
- 封装私有变量

1）setTimeout：原生的setTimeout传递的第一个函数不能带参数，通过闭包可以实现传参效果。

```js
function f1(a) {
    return function f2() {
        console.log(a);
    }
}
setTimeout(f1(1), 1000);//一秒之后打印出1
```

2）回调：定义行为，然后把它关联到某个用户事件上（点击或者按键）。代码会作为一个回调（事件触发时调用的函数）绑定到事件。

```js
function changeSize(size){
    return function(){
        document.body.style.fontSize = size + 'px';
    };
}
document.getElementById('myId').onclick = changeSize(20);
```

3）函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

实现的关键就在于`setTimeOut`这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现。

```js
function debounce(fn,delay){
    let timer = null
    return function() {
        // timer非空，说明当前正在一个计时过程中时又触发了相同事件。所以要取消当前的计时，重新开始计时
        if(timer) clearTimeout(timer) 
        // 进入该分支说明当前并没有在计时，那么就开始一个计时
        timer = setTimeOut(fn,delay) 
    }
}
```

4）封装私有变量：

```js
function generateId () {
    var i = 0
    return function() {
        console.log(i++)
    }
}
```

[闭包的使用场景]: https://www.cnblogs.com/gg-qq/p/11399152.html

### 4.2.4 具体应用

#### 1）每隔一秒输出：0 1 2

**方案1：立即执行函数 / 闭包**

```js

for (var i=0; i < 3; i++) {
    (function(x){
        setTimeout(function() {
           console.log(x);
        }, 1000*x);
    })(i);
}                           // 每隔一秒输出：0 1 2
// 改成：console.log(x+10); 	 每隔一秒输出：10 11 12

// 方法2，闭包的位置不同
 for (var i=0; i <3; i++) {
     setTimeout((function(x) {
        return () => {
           console.log(x);
        }
     })(i), 1000 * i);
}
```

匿名函数作用域链记录的是**全局的变量对象（var i，作用域提升）**，因此会在真正执行的时候运用更新后i的值。现在只需要把每一轮循环i的值保存起来，用在回调函数里面；要保存i的值，我们可以修改一下回调函数的作用域链，让**回调函数的作用域链的变量对象（x）**指向每一轮的i的值，这里用立即执行函数来实现，立即函数可以引用每一轮循环时的i的值。

**方案2：let设置局部变量**

```js
for (let i=0; i < 3; i++) {
    setTimeout(function() {
       console.log(i);
    }, 1000*i);
}                    		 // 每隔一秒输出：0 1 2
```

#### 2）私有变量/执行即输出

情况1：

```js
function generateId () {
    var i = 0
    return function() {
        console.log(i++)
    }
}
let generator = generateId();
var a = generator(); // 输出0
var b = generator(); // 输出1
generator(); // 输出2
```

情况2：

```js
function abc () {
    var flag = true
    return function() {
        if(flag) 
            console.log(0)
        else 
            console.log(1)
        flag = !flag
    }
}
abc(); // 输出0
abc(); // 输出1
abc(); // 输出0
abc(); // 输出1
```

# 5. 事件

事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。

## 5.1 事件流

事件流描述的是从页面中接收事件的顺序。但有意思的是， IE 和 Netscape 开发团队居然提出了差不多是完全相反的事件流的概念。IE 的事件流是事件冒泡流，而 Netscape Communicator 的事件流是事件捕获流。

### 5.1.1 事件冒泡

IE 的事件流叫做事件冒泡（ event bubbling），即事件开始时由**最具体的元素（文档中嵌套层次最深的那个节点）**接收，然后逐级向上传播到较为不具体的节点（文档）。所有现代浏览器都支持事件冒泡，但在 具体实现上还是有一些差别。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595156774947.png)

### 5.1.2 事件捕获

事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。如果仍以前面的 HTML 页面作为演示事件捕获的例子，那么单击<div>元素就会以下列顺序触发 click 事件。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595076826720.png)

### 5.1.3 DOM事件流

“DOM2级事件”规定的事件流包括**三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。**首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。以前面简单的 HTML 页面为例，单击<div>元素会按照图13-3所示顺序触发事件。

![img](E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595768444669.png)

在 DOM 事件流中，实际的目标（ <div>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从 document 到<html>再到<body>后就停止了。下一个阶段是“处于目标”阶段， 于是事件在<div>上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。

## 5.2 事件处理程序

事件就是用户或浏览器自身执行的某种动作。诸如 click、 load 和 mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以"on"开头，因此click 事件的事件处理程序就是 onclick。

### 5.2.1 HTML

> 使用一个与相应事件处理程序同名的 **HTML 特性**来指定（能够执行的 JavaScript 代码）。需要使用转义后的 HTML 语法字符。

```html
<input type="button" value="Click Me" onclick="alert(event.type)">    <!-- 输出 "click" -->
<input type="button" value="Click Me" onclick="alert(this.value)">    <!-- 输出 "Click Me" -->
<input type="button" value="Click Me" onclick="alert(value)">		  <!-- 输出 "Click Me" -->
<form method="post">
    <input type="text" name="username" value="123">
    <input type="button" value="Echo Username" onclick="alert(username.value)">  <!-- 输出 "123" -->
</form>
```

```
& = &amp;
" = &quot;
< = &lt;
> = &gt;     
空格 = &nbsp;
```

[HTML转义字符对照表]: https://tool.oschina.net/commons?type=2

**缺点：**

- 时差问题，调用方法的时候该方法可能还没解析。解决方法：`try{ }catch{ }`；
-  HTML 与 JavaScript 代码紧密耦合；
- 浏览器不兼容，扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。

### 5.2.2 DOM0 级

> 将一个函数赋值给一个事件处理程序属性。`btn.onclick`

优点：简单；跨浏览器。

```js
var btn = document.getElementById("myBtn");
btn.onclick = function(){
    alert(this.id); 	// "myBtn"  //程序中的 this 引用当前元素。
};
btn.onclick = null;     //删除事件处理程序
```

### 5.2.3 DOM2级/addEventListener

> `addEventListener()`和 `removeEventListener()` 接受3 个参数：要处理的事件名、作为事件处理程序的函数、一个布尔值（true：在捕获阶段调用事件处理程序；false：在冒泡阶段调用事件处理程序；一般用后者false）。

**优点：**可以添加多个事件处理程序，按顺序触发。

```js
var btn = document.getElementById("myBtn");
btn.addEventListener("click", function(){
    alert(this.id);
}, false);				// 在冒泡阶段被触发
btn.removeEventListener("click", function(){ //没有用！通过 addEventListener()添加的匿名函数将无法移除
    alert(this.id);
}, false);
```

#### 1）自定义事件

```js
 element.addEventListener('longpress', longpressFn);      //无法识别 
```

目前实现自定义事件的两种主要方式是 JS 原生的 `Event()` 构造函数和 `CustomEvent()` 构造函数来创建。

##### （1）Event()

Event() 构造函数，创建一个新的事件对象Event。

```js
 let myEvent = new Event(typeArg, eventInit);
```

其中，typeArg 是一个字符串，表示要创建的事件名称。而 EventInit 是一个可选配置项，它包含以下两个属性：

- bubbles 布尔值，表示该事件能否冒泡，默认值为 false。
- cancelable 布尔值，表示该事件是否可以取消，默认值为 false。

```js
// 创建一个支持冒泡且不能被取消的 pingan 事件
let myEvent = new Event("pingan", {"bubbles":true, "cancelable":false});
document.dispatchEvent(myEvent);

// 事件可以在任何元素触发，不仅仅是document
testDOM.dispatchEvent(myEvent);
```

##### （2）CustomEvent()

CustomEvent() 构造函数，创建一个新的事件对象CustomEvent。

```js
let myEvent = new CustomEvent(typeArg, eventInit);          
```

其中，typeArg 是一个字符串，表示要创建的事件名称。而 EventInit 是一个可选配置项，它包含以下三个属性：

- detail 任意的数据类型，表示事件初始化时，需要传递的数据，默认值为 null。
- bubbles 布尔值，表示该事件能否冒泡，默认值为 false。
- cancelable 布尔值，表示该事件是否可以取消，默认值为 false。

```js
// 创建事件
let myEvent = new CustomEvent("pingan", {detail: { name: "wangpingan" }});
// 添加适当的事件监听器
window.addEventListener("pingan", e => {
	alert(`pingan事件触发，是 ${e.detail.name} 触发。`);
});
// 添加适当的事件监听器
window.addEventListener("pingan", e => {
	alert(`pingan事件触发，是 ${e.detail.name} 触发。`);
});
document.getElementById("leo2").addEventListener(
   "click", function () {
       // 派发事件
       window.dispatchEvent(pingan2Event);
   }
)
```

##### （3）区别

- `Event()` 适合创建简单的自定义事件
- `CustomEvent()` 支持参数传递的自定义事件，它支持 detail 参数，作为事件中需要被传递的数据，并在 EventListener 获取。

### 5.2.4 IE/attachEvent

> `attachEvent()`和 `detachEvent()`接受2个参数：事件处理程序名称、事件处理程序函数。

**注意：**使用` attachEvent()`方法的情况下，事件处理程序会在全局作用域中运行，因此 this 等于 window。而DOM0中事件处理程序会在其所属元素的作用域内运行。

**优点：**可以添加多个事件处理程序，**按相反的顺序触发**。

```js
 var btn = document.getElementById("myBtn");
var handler = function(){
    alert("Clicked");
    alert(this === window); //true
};
btn.attachEvent("onclick", handler);
btn.detachEvent("onclick", handler); // 同样不能移除通过 addEventListener()添加的匿名函数
```

### 5.2.5 跨浏览器

> ` addHandler()`和`removeHandler()`接受 3 个参数：要操作的元素、事件名称、事件处理程序函数。

**缺点：**没有考虑到所有的浏览器问题，例如在 IE 中的作用域问题是window。

```js
var btn = document.getElementById("myBtn");
var handler = function(){
    alert("Clicked");
};
EventUtil.addHandler(btn, "click", handler);
EventUtil.removeHandler(btn, "click", handler);

var EventUtil = {
    addHandler: function(element, type, handler){
        if (element.addEventListener){						
            element.addEventListener(type, handler, false);// DOM2级
        } else if (element.attachEvent){
            element.attachEvent("on" + type, handler);// IE
        } else {
            element["on" + type] = handler;// DOM0级
        }
    },
    removeHandler: function(element, type, handler){
        if (element.removeEventListener){
            element.removeEventListener(type, handler, false);
        } else if (element.detachEvent){
            element.detachEvent("on" + type, handler);
        } else {
            element["on" + type] = null;
        }
    }
};
```

## 5.3 事件对象

> 对象中包含着所有与事件有关的信息。所有浏览器都支持 event 对象，但支持方式不同。

### 5.3.1 DOM

在事件处理程序内部，**对象 this 始终等于 currentTarget 的值，而 target 则只包含事件的实际目标。**

属性和方法也会因为事件类型的不同而不同，但所有事件都会有下表列出的成员：

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595816835880.png" alt="img" style="zoom: 67%;" />![img](E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1598411030699.png)

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1598411061318.png" alt="img" style="zoom:67%;" />

==`preventDefault()`方法：==阻止特定事件的默认行为。

==`stopPropagation()`方法：==用于立即停止事件在 DOM 层次中的传播，即取消进一步的事件捕获或冒泡。

==`eventPhase`属性：==用来确定事件当前正位于事件流的哪个阶段。1，捕获阶段调用的事件处理程序；2，事件处理程序处于目标对象上；3，在冒泡阶段调用的事件处理程序。

```js
var btn = document.getElementById("myBtn");
btn.onclick = function(event){
    event.preventDefault();
    event.stopPropagation();
    alert(event.eventPhase); //2   // 此时，this === target === currentTarget
};
document.body.addEventListener("click", function(event){
    alert(event.eventPhase); //1
}, true);
document.body.onclick = function(event){
    alert(event.eventPhase); //3
};
```

### 5.3.2 IE

获取事件对象的不同情况：

- HTML 特性指定的事件处理程序：event对象访问，如，event.type
- DOM0 级方法`.onclick`添加事件处理程序：采用 window.event 
- 使用 `attachEvent()` 添加：采用 window.event ；event 对象作为参数被传入事件处理程序函数

因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为 this 会始终等于事件目标。故而，最好还是使用 ==window.event.srcElement== 比较保险。

属性和方法也会因为事件类型的不同而不同，但所有事件对象都会包含下表所列的属性和方法。

<img src="E:\Cloud\工作\前端之路\前端笔记\fig\clipboard-1595818401428.png" alt="img" style="zoom:70%;" />

==`returnValue` 属性：==相当于 DOM 中的 `preventDefault()`方法，都是取消给定事件的默认行为。 `returnValue` = false即可。

==`cancelBubble` 属性：==与 DOM 中的 `stopPropagation()`方法作用相同，都是用来停止事件冒泡的。由于 IE 不支持事件捕获，因而只能取消事件冒泡；但 `stopPropagatioin()`可以同时取消事件捕获和冒泡。

```js
var btn = document.getElementById("myBtn");
btn.onclick = function(){
    alert(window.event.srcElement === this); //true
    window.event.returnValue = false; 		 // returnValue属性
    window.event.cancelBubble = true; 		 // cancelBubble属性
};
btn.attachEvent("onclick", function(event){
    alert(event.srcElement === this); //false
});
```

### 5.3.3 currentTarget和target区别

-  this、 currentTarget始终相同

- 如果直接将事件处理程序指定给了目标元素，则 this、 currentTarget 和 target 包含相同的值。
- 如果将 `li` 的事件处理程序定义在了`ul`上则target是`li`，currentTarget指向事件流过程中的元素。

## 5.4 事件代理（事件委托）

- 首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。
- 其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。（时差错误）
- 每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的 JavaScript 代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。（所以需要在不需要的时候移除事件处理程序）

> 利用事件冒泡，委托节点的父级代为执行事件。

**优点：**节点局部统一管理、避免累赘代码、动态增改元素、避免内存泄露、提高页面性能。

```js
// 点击li，弹出123
window.onload = function(){
    var oUl = document.getElementById("ul1");
    var aLi = oUl.getElementsByTagName('li');
    for(var i=0;i<aLi.length;i++){
        aLi[i].onclick = function(){
            alert(123);
        }
    }
}
// 事件委托的方式，ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的。
window.onload = function(){
    var oUl = document.getElementById("ul1");
    oUl.onclick = function(){
        alert(123);
    }
}
```

**让事件代理的效果与直接给节点的事件效果一样：**

使用Event对象提供的target属性（事件源，事件的目标节点，表示为当前的事件操作的dom）。兼容性问题如下。此时只是获取了当前节点的位置，通过`nodeName`获取具体标签名（返回的是一个大写的），需要转成小写再做比较

> event.target   		               // 标准浏览器
> window.event.srcElement    // IE浏览器

```js
var ul = document.getElementsByTagName("ul");
// 给所有li统一设置事件处理程序
ul.onclick = function(event){
    var target = event.target || window.event.srcElement
    if(target.nodeName.toLowerCase() === "li"){
        console.log(target.innerHTML)
    }
}
```

**设置不同事件处理程序**，给不同id的的li

```js
var ul = document.getElementsByTagName("ul");
ul.onclick = function(event){
    var target = event.target || window.event.srcElement
    if(target.nodeName.toLowerCase() === "li"){
        switch(target.id){
            case 'add':
                console.log("添加");
                break;
            case 'remove':
                console.log('删除');
                break;
        }
    }
}
```

**添加新事件时**，默认使其有相应的事件处理程序：

```js
window.onload = function(){
    var ul = document.getElementsByTagName("ul")[0]
    // var aLi = oUl.getElementsByTagName('li');
    var num = 4;

    //事件委托，添加的子元素也有事件
    ul.onmouseover = function(event){
        var target = event.target || window.event.srcElement
        if(target.nodeName.toLowerCase() === 'li'){
            target.style.background = "red";
        }
    };
    ul.onmouseout = function(event){
        var target = event.target || window.event.srcElement
        if(target.nodeName.toLowerCase() === 'li'){
            target.style.background = "#fff";
        }
    };

    //添加新节点
    ul.onclick = function(){
        num++;
        var li = document.createElement('li');
        li.innerHTML = 111*num;
        ul.appendChild(li);
    };
}
```

有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，解决方案：

```js
var oUl = document.getElementById('test');
oUl.addEventListener('click',function(event){
    var target = event.target;
    while(target !== oUl ){
        if(target.tagName.toLowerCase() == 'li'){
            console.log('li click~');
            break;
        }
        target = target.parentNode;
    }
})
```

[js中的事件委托或事件代理详解]: https://juejin.im/post/5acb1bcf6fb9a028dc414fc6

### 5.4.1 Vue中的事件委托

1. 注册一个事件到ul上，在利用`event.target`寻找到点击的目标，
2. `:data-index`绑定了渲染数据列表的索引
3. 在绑定的函数中获取`event.target`
4. 利用getAttribute获取我们绑定的`data-index`的索引进行操作

```html
<ul @click="handleClick">
    <li v-for="(item, index) in data" :data-index="index">
        {{ item.text }}
    </li>
</ul>
<script>
methods: {
    handleClick(event) {
        let target = event.target;
        if (target.nodeName.toLowerCase() === 'li') {
            const index = target.getAttribute("data-index");
            // this.doSomething(index)
        }
    }
}
</script>
```

# 6. 事件循环（Event Loop）

JS是单线程的，同一时间只能执行一件事，但是像ajax、setTimeOut等事件需要过一段时间后再执行它的回调函数，如果主线程一直等待就会浪费很多cpu资源。所以当我们在执行Script主体代码的时候，如果遇到这类异步事件就将他们先放到任务队列里去，将setTimeOut、setInterval等宏任务放到宏任务队列，将Promise这种任务放入微任务队列，然后继续执行Script主体代码，将代码逐个压入主线程的执行栈中执行，如果遇到新的执行环境比如一个函数，就把相应执行环境也压入执行栈中，执行完了后再出栈。

当执行栈为空时，即Script主体代码执行完毕，js引擎会先去检查微任务队列，如果不为空，则依次将微任务队列中的任务加入到执行栈中执行；如果微任务队列为空了，则将宏任务队列的中的任务逐个加入到执行栈中执行。执行完后再检查微任务队列是否为空，如此往复，就是事件循环机制。（注意：script（整体代码）作为一个宏任务，一旦全部执行完毕就会去执行其后的微任务。）

**宏任务**，包括script（整体代码），setTimeout，setInterval，setImmediate，I/O，UI交互事件，postMessage，MessageChannel ；

**微任务**，包括Promise，process.nextTick，Object.observe，MutationObserver。

**运行机制：**在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. **当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染**
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

**执行栈（主线程中）：**当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境（执行上下文），然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

**异步事件：**js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。

**事件队列：**当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去（微任务队列 ->事件队列（宏任务队列））查找是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。

[2分钟了解 JavaScript Event Loop | 面试必备]: https://www.bilibili.com/video/BV1kf4y1U7Ln/?spm_id_from=333.788.videocard.0

## 6.1 具体应用

```js
for(var i=0; i<3; i++) {
    setTimeout (function(){
        console.log(i++);
    }, 1000);
}
console.log(i);       // 输出：3 (过1s后) 3 4 5
```

注解：宏任务setTimeOut中的 i++ 在消息队列还没有执行，主线程结束后再执行 i++

# 7. Ajax

Ajax是一种异步通信的方法，不刷新页面也能取得新数据，通过直接由 js 脚本向服务器发送 http 请求，然后根据服务器返回的数据，更新网页的相应部分。核心是XMLHttpRequest 对象，XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口。

>通过XmlHttpRequest（XHR）对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。

## 7.1 XMLHttpRequest对象

XMLHttpRequest对象是浏览器提供的一个API，用来向服务器发送请求并解析服务器响应，整个过程中，浏览器页面不会被刷新。

| 事件                 | 触发条件                                                     |
| -------------------- | ------------------------------------------------------------ |
| `onreadystatechange` | 每当`xhr.readyState`改变时触发；但`xhr.readyState`由非`0`值变为`0`时不触发。 |
| `onloadstart`        | 调用`xhr.send()`方法后立即触发，若`xhr.send()`未被调用则不会触发此事件。 |
| `onprogress`         | `xhr.upload.onprogress`在上传阶段(即`xhr.send()`之后，`xhr.readystate=2`之前)触发，每50ms触发一次；`xhr.onprogress`在下载阶段（即`xhr.readystate=3`时）触发，每50ms触发一次。 |
| `onload`             | 当请求成功完成时触发，此时`xhr.readystate=4`                 |
| `onloadend`          | 当请求结束（包括请求成功和请求失败）时触发                   |
| `onabort`            | 当调用`xhr.abort()`后触发                                    |
| `ontimeout`          | `xhr.timeout`不等于0，由请求开始即`onloadstart`开始算起，当到达`xhr.timeout`所设置时间请求还未结束即`onloadend`，则触发此事件。 |
| `onerror`            | 在请求过程中，若发生`Network error`则会触发此事件（若发生`Network error`时，上传还没有结束，则会先触发`xhr.upload.onerror`，再触发`xhr.onerror`；若发生`Network error`时，上传已经结束，则只会触发`xhr.onerror`）。**注意**，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的`xhr.statusCode`是`4xx`时，并不属于`Network error`，所以不会触发`onerror`事件，而是会触发`onload`事件。 |

**方法：**

- `.open()`：准备启动一个AJAX请求；
- `.send()`：发送AJAX请求；
- `.getResponseHeader()`: 获得响应头部信息；
- `.getAllResponseHeader()`：获得一个包含所有头部信息的长字符串；
- `.abort()`：取消异步请求。XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。在终止请求之后，还应该对 XHR 对象进行解引用操作。由于内存原因，不建议重用 XHR 对象。
  - 会触发`$.ajax success`事件，所以在success是的回调函数需要添加判断ajax请求是否存在，存在才执行回调函数。
- `.setRequestHeader()`：设置请求头部信息；
  - `Accept`：浏览器能够处理的内容类型；
  - `Accept-Charset`: 浏览器能够显示的字符集；
  - `Accept-Encoding`：浏览器能够处理的压缩编码；
  - `Accept-Language`：浏览器当前设置的语言；
  - `Connection`：浏览器与服务器之间连接的类型；
  - `Cookie`：当前页面设置的任何Cookie；
  - `Host`：发出请求的页面所在的域；
  - `Referer`：发出请求的页面URI；
  - `User-Agent`：浏览器的用户代理字符串；

**属性：**

- `.responseText`：包含响应主体返回文本；
- `.responseXML`：如果响应的内容类型时`text/xml`或`application/xml`，该属性将保存包含着相应数据的XML DOM文档；
- `.status`：响应的HTTP状态；
- `.statusText`：HTTP状态的说明；
- `.readyState`：表示“请求”/“响应”过程的当前活动阶段，可取值如下：
  - **0**：未初始化 -- 尚未调用`.open()`方法；
  - **1**：启动 -- 已经调用`.open()`方法，但尚未调用`.send()`方法；
  - **2**：发送 -- 已经调用`.send()`方法，但尚未接收到响应；
  - **3**：接收 -- 已经接收到部分响应数据；
  - **4**：完成 -- 已经接收到全部响应数据，而且已经可以在客户端使用了；

## 7.2 完整Ajax请求流程

1. 准备Ajax请求

   对`readyState`属性设置监听`.onreadystatechange`事件，当`readyState`变换的时候触发。

   调用`open()`方法，设置请求方式，请求的URL，等待响应的方式（同步或异步）

2. 设置请求头

   调用XHR的`.setRequestHeader()`设置请求头

3. 发送请求

   调用XHR的`send()`发送Ajax请求

4. 处理响应

   通过`status`属性判断请求是否成功，如果成功的话，则读取`response` / `responseText`属性中存储的返回值。

### 7.2.1 Ajax原生实现

```js
// 用Promise对象实现
var getJSON = function (url) {
    var promise = new Promise((resolve, reject) => {
        var cilent = new XMLHttpRequest();
        // 必须在open()方法之前指定事件处理程序，因为open()方法的执行也包含在该事件处理程序的监听范围之内。
        cilent.onreadystatechange = function () {
            if(this.readyState !== 4)
                return;
            if(this.state === 200){
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        };
        cilent.open("POST", url, async = true); // 设置请求方式，请求的URL，等待响应的方式（同步=false / 异步=true）
        cilent.setRequestHeader("Content-type", "application/x-www-form-urlencoded") // post提交数据
        cilent.send();
    });
    return promise;
}
getJSON("/posts.json").then(json=>{
    console.log(json);
}).catch(err=>{
    console.log(err);
})
```

### 7.2.2 XHR错误处理

1）`xhr.onabort()`：**请求中断。**请求中断会触发此事件处理处理程序

2）`xhr.ontimeout()`：**超时机制。**当到达`xhr.timeout`所设置时间请求还未结束，触发此事件（从`onloadstart` -> `onloadend`）

- 注意：如果是在IE浏览器中，该属性的设置需要在`open()`方法之后和`send()`方法之前.

3）`xhr.onerror()`：**网络错误。**通过错误监听事件`xhr.onerror()`，只有发生了网络层级别的异常才会触发此事件

- 如果此时上传还没有结束，则会先触发`xhr.upload.onerror`，再触发`xhr.onerror`；如果已经上传结束只触发`xhr.onerror`
- 注意：应用层级别的异常，如响应返回的`xhr.statusCode`是`4xx`时，并不属于`Network error`，所以不会触发`onerror`事件，而是会触发`onload`事件。

4）根据`readyState`进行判断，返回的HTTP状态码`state`，HTTP状态的说明`statusText`。

## 7.3 XMLHttpRequest 2级

### 1）FormData类型

之前需要将post请求伪装为表单提交，XHR对象能够识别传入的数据类型时FormData的实例，并自动配置适当的头部信息。

```javascript
// 添加数据
let data1 = new FormData()
data1.append("name", "Tom")
xhr.send(data1)

// 提取表单数据
let data2 = new FormData(document.forms[0])
xhr.send(data2)
```

### 2）超时设定

XMLHttpRequest 2级规范提供了一个额外的属性和事件监听事件：

- `timeout`属性：设置超时时间，单位为毫秒；

- `timeout`事件：当响应时间超出实例对象timeout属性时被触发，进而调用ontimeout事件处理程序；

```javascript
// 当响应时间超过1秒时，请求中止，弹出提示框
xhr.timeout = 1000
xhr.ontimeout = () => { alert("Request did not return in a second.") }
```

### 3）overrideMimeType()方法

重写XHR响应的MIME类型

```javascript
const xhr = new XMLHttpRequest()
xhr.open("get", "example.php", true)
xhr.overrideMimeType("text/xml") // 强迫浏览器将响应数据以指定类型方式解读
xhr.send(null)
```

### 4）进度事件

定义了客户端与服务器通信相关的一系列事件，这些事件监听了通信进程中的各个关键节点，使我们能够以更细的颗粒度掌握数据传输过程中的细节。有以下6个进度事件：

- **loadstart**：在接受到响应数据的第一个字节时触发；
- **progress**：在接收响应期间持续不断地触发；
- **error**：在请求发生错误时触发；
- **abort**：在因为调用abort()方法而终止连接时触发；
- **load**：在接收到完整地响应数据时触发；
- **loadend**：在通信完成或者触发error、abort或load事件后触发。

**load事件**

通过load事件代替readystatechange事件，在响应接收完毕后将触发load事件，就没有必要去监听readystate属性了。

```javascript
const xhr = new XMLHttpRequest()
xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status <300) || xhr.status == 304) {
        alert(xhr.responseText)
    } else {
        alert("Something wrong!")
    }
}
xhr.open("get", "example.php", true)
xhr.send(null)
```

**progress事件**

可以实现加载进度条效果，因为onprogress事件处理程序会接收到一个event对象，target属性为XHR对象实例，但却额外包含着三个属性：

- `lengthComputable`：表示进度信息是否可用的布尔值；
- `position`：表示目前接收的字节数；
- `totalSize`：表示根据Content-Length响应头部确定的预期字节数；

```javascript
const xhr = new XMLHttpRequest()
xhr.onload = () => {
    if ((xhr.status >= 200 && xhr.status <300) || xhr.status == 304) {
        alert(xhr.responseText)
    } else {
        alert("Something wrong!")
    }
}
// 加载进度条
xhr.onprogress = function(event) {
    const divStatus = document.getElementById("status")
    if (event.lengthComputable) {
        divStatus.innerHTML = `Received ${event.postion} of ${event.totalSize} bytes`
    }
}
xhr.open("get", "example.php", true)
xhr.send(null)
```

## 7.4 Ajax优点

1. **无刷新更新数据。**
   AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。

2. **异步与服务器通信。**
   AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。

3. **前端和后端负载平衡。**
   并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。

4. **基于标准被广泛支持。**
   AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持JavaScript的用户提供替代功能。

5. **界面与应用分离。**
   Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。

## 7.5 fetch

`fetch() `方法来跨网络异步获取资源。给`fetch()` 提供一个参数指明资源路径，会返回一个包含响应结果的**promise对象**。

- 这个 promise 会在请求响应后被resolve，并传回 Response 对象（还要包括 Response.ok 属性为 true。）
- 当遇到网络错误时，`fetch()` 返回的 promise 会被 reject，并传回 TypeError。（HTTP 404 状态并不被认为是网络错误）

**优点**

- 解决了ajax回调地狱的问题（多层嵌套号致回调变得繁琐）
- 代码比XMLHttpRequest简洁很多，更加语义化
- 基于标准 Promise 实现，支持 async/await

**缺点：**

- API偏底层，需要进行封装

- fetch请求默认不带cookie，通过手动添加credentials： 
  - omit：默认值，忽略cookie的发送
  - same-origin：表示cookie只能同域发送，不能跨域发送
  - include：cookie既可以同域发送，也可以跨域发送 

- 浏览器支持情况不是很友好，IE 和 safari 都不支持，需要第三方库来实现

- 不支持abort和超时控制，使用setTimeout/Promise.reject实现的超时控制不能阻止请求过程继续在后台运行，造成流量浪费。

#### 与AJAX的区别

- 当接收到一个代表错误的 HTTP 状态码， 即使响应的 HTTP 状态码是 404 或 500。从 `fetch()` 返回的 Promise 不会被标记为 reject，相反，会标记为 resolve （但是会把 resolve 的返回值的 `ok` 属性设置为 false ）。
  - 只有当网络故障时或请求被阻止时，才会标记为 reject。
- 默认情况下，`fetch()` 不会从服务端发送或接收任何 cookies，如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置credentials 选项）。

## 7.6 axios拦截器实现

```js
// 定义一个拦截器类
class Interceptors {
    constructor() {
      this.handlers = [];// 保存拦截器传入的回调
    }
    use(resolveHandler, rejectHandler) {
      this.handlers.push({
        resolveHandler,
        rejectHandler
      })
    }
}
export default Interceptors
```

```js
/* this代表axios实例指向 */
let promise = Promise.resolve(configs);
// 触发请求拦截器内的所有回调
this.interceptors.request.handlers.forEach(handler => {
	promise = promise.then(handler.resolveHandler, handler.rejectHandler);
})
// 发请求
promise = promise.then(this.dispatch, undefined);
// 触发响应拦截器所有回调
this.interceptors.response.handlers.forEach(handler => {
	promise = promise.then(handler.resolveHandler, handler.rejectHandler);
})
```

## 7.7 Ajax, Axios, Fetch区别

**Ajax：**基于XHR开发，XHR本身的架构不清晰；是针对MVC的编程；单纯使用ajax却要引入整个大型JQuery

**Axios：**对原生XHR的封装；是Promise的实现版本，支持Promise API；拦截请求和响应，转换请求数据和响应数据，取消请求；自动转换 JSON 数据；客户端支持防止CSRF（token），体积小。

**Fetch：**脱离了XHR，更加底层，提供的API丰富（request, response），使用时需要进行封装

[Jquery ajax, Axios, Fetch区别之我见]: https://segmentfault.com/a/1190000012836882

# 8. 同源和跨域

## 8.1 同源策略

**同源：**协议，域名，端口相同。

**同源策略：**同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。例如CSDN在没有QQ授权登录的情况下不能获取QQ用户的用户信息。直接采用ajax读取QQ服务器的的用户数据是会被拒绝的。

- 跨域**写操作**（Cross-origin writes）一般是被允许的。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 [preflight](https://developer.mozilla.org/zh-CN/docs/HTTP/Access_control_CORS#Preflighted_requests)。
- 跨域**资源嵌入**（Cross-origin embedding）一般是被允许。
- 跨域**读操作**（Cross-origin reads）一般是**不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问。例如，你可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法。

[浏览器的同源策略]: https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy

## 8.2 跨域机制

当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。

常见跨域机制：JSONP、CORS、Web Sockets、Nginx、postMessage

### 8.2.1 JSONP

jsonp（JSON with Padding）填充式JSON（服务器将JSON**数据**填充进**回调函数**返回给浏览器）。

**jsonp实现跨域的原理：**利用script标签的src可跨域性，在GET请求的url中携带一个回调函数名，跨域的服务端把浏览器所请求的数据放入该回调函数返回给浏览器，浏览器在本地的回调函数中对返回的数据进行处理。这样就实现了不同域名下的两个站点间的交流。

**优点：**

1. JSONP可以跨越同源策略；
2. 兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持
3. 只需请求获取数据，后续操作都由调用者来自己处理。

**缺点：**

1. 只能用GET请求；
2. 在调用失败的时候不会返回HTTP状态码，不知道是否成功；
3. 安全性不好。假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么所有调用这个 jsonp的网站都会存在漏洞。所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的。

**扩展资料：**拥有”src”这个属性的标签都拥有跨域的能力，比如<\script>、<\img>、<\iframe>

1）原生实现：

```html
<body>
    <button>发起跨域请求</button>
    <script type="text/javascript">
        var handleResponse = function(data){  // 回调函数
            console.log(data)
        };
        var div = document.getElementsByTagName("button");
        div.onclick = function() {
            let url = "https://www.baidu.com?callback=handResponse"
            let script = document.createElement("script")
            script.setAttribute("src", url)
            document.getElementsByTagName("body")[0].appendChild(script)
        }
    </script>
</body>

// 服务端返回如下（返回时即执行全局函数）：
handleCallback({"status": true, "user": "admin"})
```

2.）jquery ajax：                

```js
$.ajax({
    url: 'http://www.domain2.com:8080/login',
    type: 'get',
    dataType: 'jsonp',  // 请求方式为jsonp
    jsonpCallback: "handleCallback",    // 自定义回调函数名
    data: {},
    success: {},
    err: {}
});
```

3.）vue.js：        

```js
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

[jsonp原理详解]: https://blog.csdn.net/hansexploration/article/details/80314948

### 8.2.2 CORS（跨域资源共享）

CORS 需要浏览器和后端同时支持。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。服务端设置`Access-Control-Allow-Origin` 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。相当于在后端设置了白名单，只要前端地址在这个白名单中就可以访问后端。

```java
response.setHeader("Access-Control-Allow-Origin", "*");     // 授权的源
response.setHeader("Access-Control-Allow-headers", "<header-name>, <header-name>");   // 授权源的头部字段
response.setHeader("Access-Control-Allow-Methods", "GET");  // 授权的源方法

response.setHeader("Access-Control-Allow-Credentials", "true");   // 允许Cookie的提交
```

前端设置：

```js
axios.defaults.withCredentials = true;
```

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

**简单请求和非简单请求**

#### 1）简单请求

只要同时满足以下两大条件，就属于简单请求。

1. 请求方法是以下三种方法之一：
   - HEAD
   - GET
   - POST
2. HTTP的头信息不超出以下几种字段：
   - Accept
   - Accept-Language
   - Content-Language
   - Last-Event-ID
   - Content-Type：只限于application/x-www-form-urlencoded、multipart/form-data、text/plain

#### 2）非简单请求

凡是不同时满足上面两个条件，就属于非简单请求。

#### 3）浏览器的处理

- **简单请求**，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。

- **非简单请求**的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"**预检**"请求（preflight）。浏览器先询问服务器，**当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP方法和头信息字段。**只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

  "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。

   除了Origin字段，"预检"请求的头信息包括两个特殊字段。

  - **Access-Control-Request-Method：**该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
  - **Access-Control-Request-Headers：**该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。

### 8.2.3 代理

**代理模式：**给某个对象提供一个代理对象，并由代理对象控制原对象的引用。

**反向代理和正向代理的区别**：正向代理隐藏真实客户端，反向代理隐藏真实服务端。

**正向代理**，正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。例如我们在访问 Google 时，先连上 VPN 服务器将我们的 IP 地址变成美国的 IP 地址，然后就可以顺利的访问了。

**反向代理**，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。

[正向代理 和 nginx 反向代理]: https://www.cnblogs.com/ysocean/p/9392908.html

<img src="https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180730224449157-560730759.png" alt="img" style="zoom: 67%;" />

<img src="https://images2018.cnblogs.com/blog/1120165/201807/1120165-20180730224512924-952923331.png" alt="img" style="zoom:67%;" />

#### **1）Proxy正向代理**

浏览器是禁止跨域的，但是服务端不禁止，在本地运行npm run dev等命令时实际上是用node运行了一个服务器，因此proxyTable实际上是将请求发给自己的服务器，再由服务器转发给后台服务器，做了一层代理，因为不会出现跨域问题。

vue-cli中的config > index.js中

```js
module.exports = {
	devServer: {
		proxy: { 
			'/api': {
				target: 'http://www.baidu.com/',
				pathRewrite: {
					'^/api': ''
				},
				changeOrigin: true,
				secure: false,
```

[Webpack Proxy工作原理（本地跨域）]: https://www.jianshu.com/p/8fd5d7347c57

#### 2）Nginx反向代理

修改本地 host 文件，将 www.123.com 映射到 127.0.0.1

```
127.0.0.1 www.123.com
```

配置完成之后，我们便可以通过 www.123.com:8080 访问到第一步出现的 Tomcat初始界面。那么如何只需要输入 www.123.com 便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。在` nginx.conf `配置文件中增加如下配置：

```
server {
    listen       80;
    server_name  www.123.com;
    location / {
         proxy_pass http://127.0.0.1:8080;
            index  index.html index.htm index.jsp;
        }
}
```

### 7.2.4 WebSocket

WebSocket是一种网络通信协议。http协议只能从客户端主动发起，不能从服务端推送数据到客户端；websocket就是一种不仅能从客户端发送数据到服务端，也可以主动从服务的推送数据给客户端的一种协议（**全双工通信**）。websocket没有同源限制，而且性能开销小，通信高效。 

**WebSocket特点：**

1. 建立在 TCP 协议之上，服务器端的实现比较容易。

2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3. 数据格式比较轻量，性能开销小，通信高效。
4. 可以发送文本，也可以发送二进制数据。
5. 没有同源限制，客户端可以与任意服务器通信。
6. 协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

**Websocket缺点：**部分浏览器不支持，以及服务端长期维护长连接需要一定的成本。

**Websocket应用场景：**较新浏览器支持、不受框架限制、较高扩展性。用在一些能及时响应的场景中。（如，在线聊天、数据流状态、大量数据加载）

**使用示例**

1）原生

用`socket.send`发送数据，用`socket.addEventListener`监听各类事件。

```js
// Create WebSocket connection.
const socket = new WebSocket('ws://localhost:8080');

// Connection opened
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// Listen for messages
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});
```

2）Socket.io

很好地封装了webSocket接口。引入`socket.io.js`后，用`socket.send`发送数据，`socket.on`监听`connection`、`message`、`disconnection`事件。

```html
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
    var socket = io('http://www.domain2.com:8080');

    // 连接成功处理
    socket.on('connect', function() {
        // 监听服务端消息
        socket.on('message', function(msg) {
            console.log('data from server: ---> ' + msg); 
        });
        // 监听服务端关闭
        socket.on('disconnect', function() { 
            console.log('Server socket has closed.'); 
        });
    });

    document.getElementsByTagName('input')[0].onblur = function() {  // onblur对象失去焦点时触发
        socket.send(this.value);
    };
</script>
```

### 7.2.5 postMessage

> window.postMessage：允许跨窗口通信，不论这两个窗口是否同源。

**语法：**

```javascript
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

- **otherWindow：**目标窗口，也就是给哪个窗口发消息。其他窗口的一个引用，比如是 window.frames属性的成员或者由 window.open 方法创建的窗口。

- **message：**将要发送到其他 window的数据，类型为`String`、`Object`。

- **targetOrigin：**目标窗口的源，指定哪些窗口能接收到消息事件，其值可以是字符串“*”(表示无限制)或者一个URL

**A页面通过`postMessage`发送发送消息，B页面通过`message`事件监听并接收消息**

父窗口`http://aaa.com`、子窗口`http://bbb.com`

1. 父窗口向子窗口发送消息

```javascript
// <iframe src="http://localhost:4000/b.html" id="frame" onload="load()"></iframe>
// let frame = document.getElementById('frame');
// frame.contentWindow.postMessage('Hello son', 'http://bbb.com');

var father = window.open('http://bbb.com', 'title');
father.postMessage('Hello son', 'http://bbb.com');
window.onmessage = function(event) {
  console.log(event.data); // Hello father
};
```


2. 子窗口`http://bbb.com`向父窗口`http://aaa.com`发送消息

```javascript
window.opener.postMessage('Nice to see you', 'http://aaa.com');
window.onmessage = function(event) {
  console.log(event.data); // Hello son
  event.source.postMessage('Hello father', event.origin);
};
```

**message**事件的事件对象**event**，提供以下三个属性：

- `event.source`：发送消息的窗口
- `event.origin`:  消息发向的网址
- `event.data`：消息内容

# 9. 垃圾回收与内存泄露

## 9.1 垃圾回收

> 原理：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔周期性地执行这一操作。

### 9.1.1 引用计数

> 引用计数就是记录每个变量被引用的次数，如果次数为0，就回收变量

缺点：循环引用时无法鉴别并清除。

### 9.1.2 标记清除

> 从根部开始遍历，无法达到的对象（即给当前不使用的值加上标记），然后再回收其内存。

- 垃圾收集器在运行的时候会给内存中的变量都加上标记

- 它会去掉执行环境中的变量以及被环境中的变量引用的变量的标记

- 垃圾收集器销毁这些带标记的变量

## 9.2 内存泄露

当一块内存不再用到，但是垃圾回收机制又无法释放这块内存的时候，就导致内存泄漏。减少了可用内存数量从而降低计算机性能，严重的可能导致设备停止正常工作，或者应用程序崩溃。

- **意外的全局变量**
  * 变量没有用var、let、const声明，这样的变量会加在全局环境中
  * 用this创建的，如果函数的执行环境是全局环境，而且还在函数用this创建了一个变量
  
- **被遗忘的计时器或回调函数**

  解决方法：在定时器完成工作的时候，手动清除定时器

- **脱离DOM的引用**

  比如：在js中保存了表格中某一个td元素的引用，将来如果要删除整个表格时，由于td元素是这个表格的子节点，子元素和父元素是引用关系，由于代码保留了td元素的引用，导致整个表格还在内存中

- **闭包：**闭包函数中有对外部函数变量的引用，导致外部函数还在内存中（就算外部函数执行完了）

  解决方法是，在退出函数之前，将不使用的局部变量全部删除。

  ```
  删除对象的属性       delete obj.name;
  删除其他	        str = undefined;
  删除不了原型链中的变量
  ```

- **事件监听：**对同一个事件重复监听，但是忘记移除，会导致内存泄露。
- **其他原因：**console.log打印的对象不能被垃圾回收，可能会导致内存泄露。

**1）意外的全局变量**

在函数内部定义的变量忘记加var或let，或使用this创建

```js
function foo(){
    a = 1
    this.b = 2
}
```

**2）被遗忘的计时器或回调函数**

```js
var someResource = getData(); 
setInterval(function() { 
    var node = document.getElementById('Node'); 
    if(node) { 
        // 处理 node 和 someResource 
        node.innerHTML = JSON.stringify(someResource)); 
    } 
}, 1000);
```

**3）脱离DOM的引用**

例如获取了一个dom的引用，然后将它存在一个数组或对象里；当移除这些dom节点后，仍然会存在对他们的引用

```js
var elements = { 
    button: document.getElementById('button'), 
    image: document.getElementById('image'), 
    text: document.getElementById('text') 
}
function removeButton() { 
    // 按钮是 body 的后代元素 
    document.body.removeChild(document.getElementById('button')); 
    // 此时，仍旧存在一个全局的 #button 的引用 
    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。 
}
```

**4）闭包**

因为闭包会访问函数内部的变量，这样会让这个变量一直存在内存中，无法被回收。

### 9.2.1 检测和处理

**检测：**Chrome的开发者工具timeline检测内存占用或profiles来进行快照对比。Node提供的`process.memoryUsage()`方法来检查内存泄露。

**处理：**及时对无用的数据进行垃圾回收。减少使用不必要的全局变量或生命周期较长的变量。变量导致的内存泄露，将变量清除 a = null 即可。事件监听导致的内存泄露，监听后移除即可。

​    ![0](http://note.youdao.com/yws/public/resource/9482e8b87ef677a6aea76190f84e66bf/xmlnote/WEB45b9283480882b402a57108968904df8/WEBRESOURCEedacf6080f6d7b97b2306c2c0078a78a/11148)

# 10. 防抖和节流

在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。

## 10.1 防抖（debounce）

> 防抖：事件被触发n秒后执行，如果在之后n秒内再次被触发，则重新计时。

应用场景：一般可以使用在用户输入停止一段时间过后再去获取数据，而不是每次输入都去获取。

- 搜索框的提示文字，防抖节约请求资源；
- window触发resize时，停止执行resize事件才会触发一次；
- 有道云笔记的保存。

![img](https://user-gold-cdn.xitu.io/2018/6/10/163e9f9241e349d2?imageslim)

以下代码，拖动滚动条放开1000ms后触发`handle`方法

```js
function debounce(fn, delay=500) {
    let timeout = null;   // 创建一个标记用来存放定时器的返回值(timeout是闭包中的)
    return function () {
        if(timeout) {
            clearTimeout(timeout);      // 每当用户输入的时候把前一个 setTimeout clear 掉      
        }
        // 然后又创建一个新的setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
        timeout = setTimeout(() => {    
            fn.apply(this, arguments);  //fn()也可，就是在用到debounce(()=>{}) 箭头函数时传参可能出问题
            timeout = null;
        }, delay);
    };
}
// 处理函数
function handle() {
    console.log("触发一次"); 
}
// 滚动事件
window.addEventListener('scroll', debounce(handle, 1000));
```

## 10.2 节流（throttle）

>指定时间间隔内只会执行一次任务。

应用场景：可以将一些事件降低触发频率。

- 用户点击提交按钮，秒杀商品。
- 在滚动页面时做到页面延时加载，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。
- 拖拽一个元素时，要随时拿到该元素被拖拽的位置（直接用drag事件，则会频发触发，易卡顿）；
- 射击类游戏不停点击鼠标，但以一定固定频率射击。

![img](https://user-gold-cdn.xitu.io/2018/6/10/163e9f9241c653a8?imageslim)

**时间戳节流：**

- 第一次会立即执行；
- 最后一次事件触发完毕后，事件也不会再被执行了。

**定时函数：**

- 第一次不会立即执行函数，而是在delay秒后才执行；
- 最后一次停止触发后，由于定时器delay延迟，可能还会执行一次。

```js
// 利用时间戳节流：
var throttle = function(func, delay) {
    var prev = Date.now();
    return function() {
        var now = Date.now(),
            context = this,
            args = arguments;
        if (now - prev >= delay) {	// 如果距离上一次事件触发的时间间隔超过delay，则执行 
            func.apply(context, args);
            prev = Date.now();	// 将pre置为当前时间
        }
    }
}

// 利用定时函数：
var throttle = function(func, delay) {
    var timer = null;
    return function() {
        var context = this,
            args = arguments;
        if (!timer) {
            timer = setTimeout(function() {
                func.apply(context, args);
                timer = null;
            }, delay);
        }
    }
}
function handle() {
    console.log("触发一次"); 
}
window.addEventListener('scroll', throttle(handle, 1000));
```

[JS的防抖与节流]: https://juejin.im/entry/5b1d2d54f265da6e2545bfa4

# 11. 数据存储

HTTP是无状态的，而实际Web运用中，我们会希望HTTP可以保存一些已有的状态信息，方便服务器端跟踪会话。因此，先后使用了Cookie和Session机制来解决HTTP的无状态问题。

## 11.1 Cookie/session/token

### 11.1.1 Cookie

Cookie机制一种是客户端保存状态信息的方案，实际上Cookie就是一小段的文本信息，储存在浏览器内存中。

**Cookie相关首部字段：**

- `set-cookie`：开始状态管理所使用的 Cookie 信息(响应首部字段)
- `cookie`：服务器接收到的 Cookie 信息(请求首部字段)

| **Cookie属性** | **说明**                                                     |
| -------------- | ------------------------------------------------------------ |
| name           | 一个cookie的名称                                             |
| value          | 一个cookie的值                                               |
| size           | cookie大小                                                   |
| expires        | 绝对失效时间。默认cookie是暂时存在的，当用户退出浏览器后这些值也会丢失；如果指定 expires 值，那么在时间没有过期的情况下cookie会始终存在 |
| max-age        | 与expires作用相同，表示此cookie多久过期（单位是秒），但不是一个固定的时间点。正常情况下，max-age的优先级高于expires |
| secure         | 传输类型，默认不安全传输。指定后，只有在使用SSL连接时才能将该cookie信息发送给服务器，如果是普通http连接则不会发送 |
| HttpOnly       | 设为true后，只能通过http访问，不能通过document.cookie获取。可防止xss读取cookie |
| SameSite       | 防止 CSRF 攻击和用户追踪。`Strict`最为严格，任何情况下都不会发送 cookie；`Lax`规则稍稍放宽，导航到目标网址的 Get 请求（链接，预加载请求，GET 表单）可以携带cookie；显式关闭`SameSite`属性的`None`，与`Secure`属性同时设置才会生效。 |
| domain         | 设定cookie对于哪个域是有效的，所有向该域发送的请求中都会包含这个cookie信息 |
| path           | 表示cookie所在的目录，该目录下的所有网页文件都能访问和使用该cookie |

#### 1）Cookie传输过程

利用Cookie进行http通信的过程主要是：

1. 客户端第一次发送一个http请求到服务器
2. 服务器处理后返回一个http响应，该响应头里会包含一个Set-Cookie字段，存放服务器生成的Cookie信息
3. 客户端接收到该响应后，将Cookie保存下来
4. 之后客户端每次向该服务器发送http请求时，都会将该Cookie塞进请求头中的Cookie字段，一起发送给服务器

#### 2）Cookie应用场景

- 记住密码
- 购物车商品缓存，从不同页面加入购物车（需要考虑安全和性能）

#### 3）Cookie如何存储

```js
// cookie存到localStorage中，sessionStorage同理
localStorage.setItem("cookie", JSON.stringify(obj)); 
localStorage.getItem("cookie"); 
localStorage.removeItem("cookie"); 
localStorage.clear();
```

#### 4）Cookie操作

`Cookie.js`

```js
function setCookie(name,value){
    var exp = new Date();
    exp.setTime(exp.getTime() + 12*60*60*1000);
    document.cookie = name + "=" + value + ";expires=" + exp.toGMTString();
}
function delCookie(name)
{
    var exp = new Date();
    exp.setTime(exp.getTime() - 1);// 设置cookie失效时间为当前时间的前一天,说明cookie的有效期是在过去，即删除cookie
    var value = getCookie(name);
    if(value != null)
        document.cookie = name + "=" + value + ";expires=" + exp.toGMTString();
}
function getCookie(name)
{
    var _name = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) 
    {
        var c = ca[i].trim();
        if (c.indexOf(_name)==0) {
            return c.substring(_name.length,c.length);
        }
    }
    return "";
}
export {setCookie, getCookie, delCookie}
```

存到原型上和存到cookie中的区别？

### 11.1.2 Session

Session机制是一种服务器保存状态信息的方案。服务器使用一种类似于散列表的结构来保存session信息（包括在服务器内存中）。

当某个客户端用户的请求到达服务器时，服务器首先检查这个请求里是否已包含了一个sessionid，如果包含说明以前已经为此客户端用户创建过session，服务器就按照sessionid把这个session检索出来使用，如果不包含sessionid，服务器会为此客户端用户创建一个session并且生成一个与此session相关联的sessionid，这个sessionid将被在本次响应中返回给客户端保存。

### 11.1.3 Token

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

**工作流程如下：**

1. 用户输入登陆凭据（如，用户名密码）；
2. 服务器验证凭据是否正确，然后返回一个经过签名的token（使用凭据加密成token）；
3. 客户端负责存储token，可以存在localStorage/sessionStorage中；
4. 对服务器的请求带上这个token； 
5. 服务器对JWT进行解码（解密成凭据然后验证），如果token有效，则处理该请求；
6. 一旦用户登出，客户端销毁token

#### （1）JWT Token

**组成部分：**头部（header）、载荷（payload）、签证（signature）

**优点：**

- **可扩展性好。**应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者redis里面。而jwt不需要
- **无状态。**jwt不在服务端存储任何状态

**缺点：**

- **安全性：**jwt的payload没有加密，因此jwt中不能存储敏感数据。而session的信息是存在服务端的，相对来说更安全
- **性能：**jwt太长，sessionId很短，用jwt放在header中可能比body还大，cookie可能放不下
- **一次性：**想修改里面的内容，就必须签发一个新的jwt

**使用场景：**有效期短；只希望被使用一次

[用户认证：基于jwt和session的区别和优缺点]: https://juejin.im/post/6844903856942350349#heading-10

<img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="img" style="zoom: 67%;" />

算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（`.`）分隔，就可以返回给用户。

##### Header

Header 部分是一个 JSON 对象，描述 JWT 的元数据。最后使用 Base64URL 算法将 JSON 对象转成字符串。

- `alg`属性表示签名的算法，默认是 HMAC SHA256（写成 HS256）；
- `typ`属性表示这个令牌（token）的类型（type），JWT 令牌统一写为`JWT`。

##### Payload

Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。也可以定义私有字段。

```js
iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
```

##### Signature

Signature 部分是对前两部分的签名，防止数据篡改。首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。

```js
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

##### 服务端验证

服务端收到token， 取出Header、Payload对其进行HMACSHA256()算法取哈希，再使用私钥进行加密，得到新的数字签名，比较新的数字签名和原本的数字签名，若一致，则认证通过。

### 11.1.4 区别与联系

**Cookie和Session的区别和联系**

1. **存储位置：**Cookie是把用户的数据存到本地，而Session则是把用户的数据存在服务器。
2. **安全性：**Cookie保存在客户端本地，有可能会被人窃取用来欺骗服务器，Session可将敏感信息保存在服务器，且不会任意读取，比Cookie更加安全。
3. **限制：**Cookie的大小和数量都有限制，如果很大，每次要请求都要带上，这样就影响了传输效率；Session会在一定时间内保存在服务器内存上，当访问增多会比较占用你服务器的性能。
4. **联系：Session需要用Cookie存储sessionid。**Session虽然保存在服务器，但它仍然需要Cookie作为sessionid的容器发送给客户端，若客户端禁用了Cookie，会一定程度上影响Session的使用。

**Token和Session的区别和联系**

1. **存储位置：**sessionid一般利用Cookie作为容器进行传输和保存，token可以放在**请求或响应的body内传输，储存在浏览器的localStorge里。**

2. 服务端需要内存空间去存储session，而可以不需要存储token。对于这种无状态token，服务器可以通过在token中**附加“签名”的方式**来确认请求中的token是由自己签发，从而验证token的有效性。

 **Token相对Cookie的优势**

token的验证是无状态的，这是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。（更安全，防止CSRF攻击）

## 11.2 Web存储机制

**两个主要目标是：**

- 提供一种在 cookie 之外存储会话数据的途径；
- 提供一种存储大量可以跨会话存在的数据的机制。

**Storage 实例的方法：**

- `key(index) `：获得 index 位置处的值的名字。

- `getItem(name)` ：根据指定的名字 name 获取对应的值。
- `setItem(name, value)` ：为指定的 name 设置一个对应的值。
- `removeItem(name) `：删除由 name 指定的名值对儿。
- `clear() `： 删除所有值；Firefox 中没有实现 。

**Storage 实例的事件：**对 Storage 对象进行任何修改，都会在文档上触发 storage 事件。这个事件的 event 对象有以下属性。

- `domain` ：发生变化的存储空间的域名。
- `key` ：设置或者删除的键名。
- `newValue` ：如果是设置值，则是新值；如果是删除键，则是 null 。
- `oldValue` ：键被更改之前的值

### 11.2.1 localStorage、sessionStorage、cookies

SessionStorage，LocalStorage，Cookie这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者都是**html5 提供的浏览器本地存储的方法**。而cookie是**服务器端用于记录用户状态的一种方式**，由服务器设置，在客户端存储。cookie 数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递。

**（1）存储大小：**

- cookie 数据大小不能超过4 k。
- sessionStorage 和 localStorage 大多数桌面浏览器限制 5MB ，Chrome、Safari、Android 版 WebKit 限制 2.5MB。

**（2）过期时间：**

- cookie在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
- localStorage存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据。
- sessionStorage数据在**页面会话结束**时会被清除。

**（3）数据共享：**

- cookie和localStorage在所有同源窗口中数据都是共享的。
- sessionStorage只在同源的同窗口(或标签页)中共享数据，也就是只在当前会话中共享。

### 11.2.2 indexDB

indexDB **用于大规模数据存储。**它不是关系型数据库，它内部采用**对象仓库的形式**存储数据，它更接近 NoSQL 数据库。

**扩展：**

- webSQL，同样用于大规模数据存储（已被废除）
- userData，IE 支持的存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。

# 12. 错误处理（排查）

## 12.1 JS出错如何排查

- **在编码的时候提高编码质量：**统一的编码规范、功能模块化、代码易读性、写注释。

- **阅读报错信息：**根据报错信息进行错误代码和错误类型定位（见下面白屏处理，根据不同错误信息作出反应）
- js代码格式错误，通常ESLint会输出报错
  - 不清楚就google/baidu，去stackoverflow，segmentfault等专业问答网站
  
- **善用console + Debug：**检查错误的具体位置、具体什么错误。

- **适当进行代码测试**

- **测试某段代码是否有效**
- 代码的选择性注释，找到问题所在。
  - 排除法，放到其他地方运行

## 12.2 线上故障排除

**在webpack的配置文件中开启Source Map**，在打包的时候会生成对应的.map文件。然后将打包过的文件整体上传到服务器，这样调试线上代码时，除了压缩混淆过的代码，还会有一份原始代码，方便打断点和阅读代码。

Source map就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。

**缺点：**打包时间会变长；将原生代码暴露出去。

**注意：**平时建议关闭sourceMap功能，只有在修复无法在本地重现的线上bug时再使用。而且，在修复完毕后，重新打一个没有sourceMap的包，上传到服务器，避免本地代码泄露。

## 12.3 页面白屏问题排查

（腾讯）页面白屏问题如何检查错误，有以下两种主要原因：

- JS报错，运行时抛出异常
- 静态资源加载失败，如：js、css文件加载失败

1. 用户问题：确保网络连接通畅；网络url地址是否输入有误
2. F12 使用Devtools开发者模式查看是否有报错信息
   - 有报错，看看`Element`上有没有元素，是不是被隐藏了，或者没有传过来
   - 检查`Network`，可能是服务器问题，部分资源加载不进来
     - 静态资源是否加载失败（资源加载顺序也需关注下），可能是第三方CDN报错（可以对静态资源设置监控功能）
     - 请求接口是否异常，检查`request`、`response`、http状态码是否正常
       - 5开头的状态码，一般是后端问题，后端查看accesslog、程序日志
       - 4开头的状态码，一般是前端问题，根据给出的js异常进行排查，检查request url是否正确（可能项目中做了重定向，路由配置问题）
       - 查看路由是否有path或者name的错误，导致加载了不存在的页面。

**开发时的性能优化：**

1. 减少文件加载体积，如html，js，css压缩，图片合并等
2. 使用本地存储处理静态文件。
3. 开发时注意将css放到head中，或js加载放在最后，以及使用async/defer的方法
4. js执行懒加载方式

[怎么解决前端线上Bug]: https://www.cnblogs.com/warm-stranger/p/12015533.html
[前端面试题：页面出现空白，怎么排查定位问题？]: https://segmentfault.com/q/1010000015669214

# 13. 柯里化

> **只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数**。

柯里化是一个逐步接收参数的过程。它可以参数复用，延迟执行。

将多个参数的函数转换为单参数函数链的形式。提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接收剩余参数的函数。

**优点（应用场景）：**

- 参数复用。提前绑定好函数里的某些参数，达到复用的效果
- 延迟执行
- 固定易变元素

### 13.1 sum(1)(2)(3)

sum(1, 2, 3)，sum(1)(2, 3)，sum(1, 2)(3)，sum(1)(2)(3)的结果

```js
function sum() {
    let args = [...arguments]; // [].slice.call(arguments) // Array.from
    function add() {
        args = args.concat(...arguments);
        if (args.length >= 3) { // 判断参数的长度
            return args.reduce((a, b) => (a + b));
        }
        return add;
    }
    return add();
}
console.log(sum(1, 2, 3))
console.log(sum(1)(2, 3))
console.log(sum(1, 2)(3))
console.log(sum(1)(2)(3))
```

### 13.2 sum(1)(2)(3)()

sum(1)(2)(3)()，sum(1)(2, 3)()、sum(1,2)(3)()，sum(1,2,3)()的结果

```javascript
function sum() {
    let args = [...arguments]; // [].slice.call(arguments) // Array.from
    function add() {
        args = args.concat(...arguments); // 缓存所有的参数值
        if (arguments.length === 0) {  // 如果参数为空，则停止递归，求和
            return args.reduce((a, b) => (a + b));
        }
        return add;
    }
    return add;
}
console.log(sum(1, 2, 3)())
console.log(sum(1)(2, 3)())
console.log(sum(1, 2)(3)())
console.log(sum(1)(2)(3)())
```

### 13.3 sumOf函数求和

add(1)(1,2)().sumOf()，也可以是add()(2)()(3).sumOf()，也可以是add(1)(2)(3).sumOf()

```javascript
function add() {
    let args = [].slice.call(arguments)
    let currying = function() {
        args.push(...arguments)
        return currying
    }
    currying.sumOf = function() { // 以某个函数名结束，也可以是valueOf等自定义函数名
        return args.reduce((a, b) => (a + b))
    }
    return currying
}
console.log(sum2(1)(1,2)().sumOf()); // 4
console.log(sum2()(2)()(3).sumOf()); // 5
console.log(sum2(1)(2)(3).sumOf());  // 6
```

### 13.4 高阶函数

高阶函数：把函数作为参数传入

```js
function defineFunc(fn, args) {  // 函数的长度就是定义形参的个数  
    args = args || fn.length; //如果不传参就设置为函数传参的个数      
    return function recall() {    
        return arguments.length < args //比较传入参数的个数与设置的参数个数是否相等      
            ? recall.bind(this, ...arguments) //不等就继续recall函数添加参数      
        : fn.call(this, ...arguments); //相等就执行函数，然后返回结果  
    };
}
let sum3 = defineFunc((a, b, c) => a + b + c) //返回的是recall函数
console.log(sum3(1,2,3)) //6
console.log(sum3(1)(2,3) === sum3(1,2)(3)) //true
```

# 14. DOM

> DOM（文档对象模型）是针对HTML和XML文档的一个API。DOM为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构，DOM由节点组成。

**节点：** 节点是构成HTML网页的最基本单元，网页中的每一个部分都可以称为是一个节点，比如html标签、属性文本、注释、整个文档等都是一个节点。

常见节点分为以下四类：

- 文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。
- 元素节点（标签）：HTML标签。
- 属性节点（属性）：元素的属性。
- 文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。

**DOM的用途：**

- 找元素节点
- 设置元素的属性值
- 设置元素的样式
- 动态创建和删除元素
- 事件的触发响应

## 14.1 DOM操作

### 1）获取节点

**1.getElementById()**通过元素ID查找，返回文档中第一次出现的元素。

```javascript
var div = document.getElementById("box1");
```

**2.getElementsByTagName()**通过标签名查找，返回一个NodeList。在HTML文档中，这个方法会返回一个HTMLCollection对象。

```javascript
var arr1 = document.getElementsByTagName("div");
```

取出保存在NodeList中元素的方法如下：

```javascript
arr1[0];
arr1.item(1);
```

**3.getElementsByClassName()**通过类名获取元素节点数组。

```
var arr2 = document.getElementsByClassName("hehe");
```

**4.querySelector()**接受一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配的元素，则返回null。

```javascript
var body = document.querySelector("body");		//获取body元素
var myDiv = document.querySelector("#myDiv");	//获取ID为"myDiv"的元素
var myDiv = document.querySelector(".box1")		//获取类为"box1"的第一个元素
```

**5.querySelectorAll()**与querySelector()类似，只是返回的是一个NodeList实例，包含所有匹配的元素。

```javascript
var body = document.querySelectorAll("li");	//获取所有<li>元素
var myDiv = document.querySelectorAll(".box1")	//获取所有类为"box1"的元素
```

### 2）获取/设置元素的属性值

```javascript
element.getAttribute(attributeName)   			    // 括号传入属性名，返回对应属性的属性值
element.setAttribute(attributeName,attributeValue)  // 传入属性名及设置的值
```

### 3）创建节点

```javascript
document.createElement("h3")  	  	// 创建一个html元素，这里以创建h3元素为例
document.createTextNode(String); 	// 创建一个文本节点；
document.createAttribute("class");  // 创建一个属性节点，这里以创建class属性为例
```

### 4）添加节点

```javascript
element.appendChild(Node);					 // 往element内部最后面添加一个节点，参数是节点类型
elelment.insertBefore(newNode,existingNode); // 在element内部的中在existingNode前面插入newNode
```

### 5）删除节点

```javascript
element.removeChild(Node)	//删除当前节点下指定的子节点，删除成功返回该被删除的节点，否则返回null
```

### 6）替换节点

```javascript
element.replace(newNode, existingNode)
```

## 14.2 Dom属性

**1 获取当前元素的父节点**

```javascript
element.parentNode 	// 返回当前元素的父节点对象
```

**2 获取当前元素的子节点**

```javascript
element.chlidren	// 返回当前元素所有子元素节点对象，只返回HTML节点
element.chilidNodes // 返回当前元素所有子节点，包括文本，HTML，属性节点。（回车也会当做一个节点）
element.firstChild  // 返回当前元素的第一个子节点对象
element.lastChild	// 返回当前元素的最后一个子节点对象
```

**childNodes和children的区别？**

都返回父元素所有的直系子节点的集合。

- **children**：只返回HTML元素节点，不包括文本节点和属性节点。
- **childNodes**：与children不同的是，childNodes会返回HTML元素节点，属性节点，文本节点。

**3 获取当前元素的同级元素**

```javascript
element.nextSibling		// 返回当前元素的下一个同级元素 没有就返回null
element.previousSibling	// 返回当前元素上一个同级元素 没有就返回 null
```

**4 获取当前元素的文本innerHTML、innerText、textContent**

|    字段     | 描述                                                         |
| :---------: | ------------------------------------------------------------ |
|  innerHTML  | 获取HTML文本结构所有内容。                                   |
|  innerText  | 获取指定节点的文本及其后代节点中**文本内容，不能**获取< script>和< style>元素中的内容 |
| textContent | 获取指定节点的文本及其后代节点中**文本内容，可以**获取< script>和< style>元素中的内容， |

- textContent能够获取元素的所有子节点上的文本，不管这个节点是否呈现（是否有`display:none`）；而innerText只返回呈现到页面上的文本。
- 由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但 textContent 不会。

**5 获取当前节点的节点类型**

```javascript
node.nodeType   // 返回节点的类型,数字形式（1-12）；常见几个1：元素节点，2：属性节点，3：文本节点。
```

**6 设置样式**

```js
element.style.color=“#eea”;		// 设置元素的样式时使用style
```

# 15. 正则表达式

参考元素：[正则表达式中各种字符的含义](https://www.cnblogs.com/afarmer/archive/2011/08/29/2158860.html)

## 15.1 元字符

![](https://i.loli.net/2020/07/02/WruLt5fEJVglp6m.png#alt=image-20200620150508102)

## 15.2 修饰语

![](https://i.loli.net/2020/07/02/GMyT7Nt8qi6jmBV.png#alt=image-20200620150540003)

## 15.3 方法

#### 字符串方法

- **search()**

检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回字串的起始位置；

```javascript
var str = "Hello World"; 
var n = str.search(/World/i);  // 6
```


- **replace()**

在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串

```javascript
// 使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Runoob
var txt = str.replace(/microsoft/i,"Runoob");
```

#### 使用RegExp对象

- **test()**

检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false;

```javascript
var patt = /e/;
patt.test("The best things in life are free!"); //true
```


- **exec()**

检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null；

```javascript
/e/.exec("The best things in life are free!");  // e
```

## 15.4 常见应用

#### 1）转化成驼峰形式

```
{'a_b': {'a_b_c': {'a_b_c_d': '1'}}}  --->  {'aB': {'aBC': {'aBCD': '1'}}}
```

```js
// 匹配横杆以及之后的一个字符，\g全局匹配
// \w匹配任何单个 "单词" 字符, 即字母, 数字或下划线，等同于 [a-zA-Z0-9_]

// 字符串的下划线格式转驼峰格式，eg：hello_world => helloWorld
function underline2Hump(s) {
  return s.replace(/_(\w)/g, function(all, letter) {
    return letter.toUpperCase()
  })
}

// 字符串的驼峰格式转下划线格式，eg：helloWorld => hello_world
function hump2Underline(s) {
  return s.replace(/([A-Z])/g, '_$1').toLowerCase()
}

// JSON对象的key值转换为驼峰式
function jsonToHump(obj) {
  if (obj instanceof Array) {
    obj.forEach(function(v, i) {
      jsonToHump(v)
    })
  } else if (obj instanceof Object) {
    Object.keys(obj).forEach(function(key) {
      var newKey = underline2Hump(key)
      if (newKey !== key) {
        obj[newKey] = obj[key]
        delete obj[key]
      }
      jsonToHump(obj[newKey])
    })
  }
  return obj;
}

// JSON对象的key值转换为下划线格式
function jsonToUnderline(obj) {
  if (obj instanceof Array) {
    obj.forEach(function(v, i) {
      jsonToUnderline(v)
    })
  } else if (obj instanceof Object) {
    Object.keys(obj).forEach(function(key) {
      var newKey = hump2Underline(key)
      if (newKey !== key) {
        obj[newKey] = obj[key]
        delete obj[key]
      }
      jsonToUnderline(obj[newKey])
    })
  }
  return obj;
}

var json = {'a_b': {'a_b_c': {'a_b_c_d': '1'}}}
console.log(jsonToHump(json))
```

#### 2）数字转成千分位

- 第一个逗号前最多可以有1至3个数字，正则：`/\d{1,3}/`

- 第一个逗号后面数字的个数是3的倍数，正则：`/(\d{3})+$/`
- 判断后面是否满足条件`(?=)`

```js
var str = "87463297";
var newStr = str.replace("/\d{1,3}(?=(\d{3})+$)/g" ,function(s){
  return s+','
})
console.log(newStr);
```

#### 3）去除字符串首尾空格

```js
String.prototype.trim = function(){
    var reg = /(^\s*|\s*$)/g;    // 表示以空格开头或以空格结尾  /g：全局搜索
    return  this.replace(reg, "");
}
```

[js正则表达式常见面试题]: https://blog.csdn.net/weixin_30911809/article/details/97520447?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

# 16. 其他

## 16.1 字符串当做js代码来执行

- eval() 动态解析和执行字符串，不安全，非常耗性能

- new Function() 把传入的字符串封装为anonymous匿名函数并返回

- setTimeOut() / setInterval()

- script / import

```js
eval("console.log(a)"); 	
(new Function('','console.log(a)'))(); 	
setTimeOut("console.log(a)", 0);
setInterval("console.log(a)", 0);
```

# 17. 语言

## 17.1 面向对象

面向对象语言：JAVA，C++，C#，python，PHP等。

### 1）封装

隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。

- **目的：**增强安全性和简化编程，使用者不必了解具体实现细节，而只是要通过外部接口，一特定的访问权限来使用类的成员。
- **基本要求：**把所有的属性私有化，对每个属性提供`getter`和`setter`方法，如果有一个带参的构造函数的话，那一定要写一个不带参的构造函数。在开发的时候经常要对已经编写的类进行测试，所以在有的时候还有重写`toString`方法，但这不是必须的。

### 2）继承

**对现有类进行扩展。**可以使用现有类的所有功能，在不需要重新编写原来的类的情况下对这些功能进行扩展。

- **目的：**实现代码的复用。

- **具体描述：**当两个类具有相同的特征（属性）和行为（方法）时，可以将相同的部分抽取出来放到一个类中作为父类，其它两个类继承这个父类。继承后子类自动拥有了父类的属性和方法，但特别注意的是，**父类的私有属性和构造方法并不能被继承**。另外子类可以写自己特有的属性和方法，目的是实现功能的扩展，子类也可以复写父类的方法即方法的重写。子类不能继承父类中访问权限为private的成员变量和方法。子类可以重写父类的方法，及命名与父类同名的成员变量。

  protected：需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。

![img](https://img-blog.csdn.net/20160516112715694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### 3）多态

**允许不同类的对象对同一消息做出响应。**即同一消息可以根据发送对象的不同而采用多种不同的行为方式。

- 多态的作用：消除类型之间的耦合关系。

### 重载和重写

- **重载：**发生在同一个类中，函数名相同但参数不同。

- **重写：**发生在子类中，对继承的父类的对应方法进行重写（要求函数名和参数均相同）。

**Java实现多态：**

```java
public class Test {
    public static void main(String[] args) {
      show(new Cat());  // 以 Cat 对象调用 show 方法
      show(new Dog());  // 以 Dog 对象调用 show 方法
                
      Animal a = new Cat();  // 向上转型  
      a.eat();               // 调用的是 Cat 的 eat
      Cat c = (Cat)a;        // 向下转型  
      c.work();              // 调用的是 Cat 的 work
    }  
    
    public static void show(Animal a)  {
      a.eat();  
        // 类型判断
        if (a instanceof Cat)  {  // 猫做的事情 
            Cat c = (Cat)a;  
            c.work();  
        } else if (a instanceof Dog) { // 狗做的事情 
            Dog c = (Dog)a;  
            c.work();  
        }  
    }  
}

abstract class Animal {  
    abstract void eat();  
}  
  
class Cat extends Animal {  
    public void eat() {  
        System.out.println("吃鱼");  
    }  
    public void work() {  
        System.out.println("抓老鼠");  
    }  
}

class Dog extends Animal {
    public void eat() {
        System.out.println("吃骨头");  
    }
    public void work() {  
        System.out.println("看家");  
    }
}
/* 吃鱼 抓老鼠   吃骨头 看家   吃鱼 抓老鼠 */
```

### 17.1.1 面向对象和面向过程

**面向过程：**分析出解决问题所需的步骤，然后用函数依次调用来一步一步实现。

**面向对象：**以功能来划分问题，分解成各个对象，描述某个事物在整个解决问题的步骤中的行为。

### 17.1.2 JavaScript中的面向对象

- **封装：闭包**
- **继承：原型链**
- **多态：弱类型**

#### JavaScript实现多态

```js
var makeSound = function(animal) {
    animal.sound();
}

var Duck = function(){}
Duck.prototype.sound = function() {
    console.log('嘎嘎嘎')
}
var Chiken = function() {};
Chiken.prototype.sound = function() {
    console.log('咯咯咯')
}

makeSound(new Chicken());
makeSound(new Duck());
```

## 17.2 解释型语言和编译型语言

### 17.2.1 编译型语言

编译型语言，在程序执行之前先将程序翻译成机器语言，之后就不用再进行翻译了。（C/C++编译后可形成独立执行的exe文件 ）

- **由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。**

### 17.2.2 解释型语言

解释型语言，在运行的时候将程序翻译成机器语言。（Java，C#，**JavaScript**，PHP）。

- Java在运行之前的编译过程，不是将程序编译成机器语言，而是将它编译成字节码，在运行的时候由JVM将字节码翻译成机器语言。

### 17.2.3 对比

| 对比 |             编译型语言             |                          解释型语言                          |
| :--: | :--------------------------------: | :----------------------------------------------------------: |
| 速度 |            执行速度更快            | 速度慢（先运行相关解释器，有”解码-抓取-执行“周期，安全性检查） |
| 内存 |           消耗的内存更少           |                 消耗内存多（复杂的，智能的）                 |
| 实现 |                 /                  |                      解释器比较容易实现                      |
| 调试 |  （例如空指针异常在C中难以定位）   |                     提供了很好的调试支持                     |
| 平台 | 是面向特定平台的，所以需要依赖平台 |                          平台独立性                          |
| 安全 |       不支持代码中实现安全性       |                       保证高度的安全性                       |

## 17.3 JavaScript特点

- **解释型语言：**在运行的时候被逐行地解释。
- **弱类型语言：**没有使用严格的数据类型，更注重逻辑，而更少的关心语法的问题。缺点就是类型转换比较复杂，没有一种类型判断方法能够一次判断出所有类型。
- **跨平台性脚本语言：**依赖于浏览器本身，与操作环境无关，只要计算机能运行支持JavaScript的浏览器，就可正确执行。
- **面向对象：**运用已经创建的对象。
- **相对安全脚本语言：**不被允许访问本地的硬盘，且不能将数据存入服务器，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。从而有效地防止数据的丢失或对系统的非法访问。
- **事件驱动脚本语言：**用户在网页中执行了某些操作产生的事件（Event），引起对应事件响应并执行对应脚本。例如按下鼠标、移动窗口、选择菜单等。

**优点：**

- **减少网络传输：**传统的数据提交和验证工作均由客户端通过网络传输到服务器上进行。如果数据量很大，对于网络和服务器的资源来说实在是一种无形的浪费。而使用JavaScript就可以在客户端进行数据验证。
- **方便操纵HTML对象：**方便地操纵各种页面中的对象，控制页面中各个元素的外观、状态和运行方式，根据用户的需要“定制”浏览器，从而使网页更加友好。
- **支持分布式运算：**使多种任务仅在用户端就可以完成，而不需要网络和服务器的参与，从而支持分布式的运算和处理。

**缺点：**

- **弱类型语言的类型转换比较复杂，**没有一种类型判断方法能够一次判断出所有类型。
- **内存泄漏：**闭包，被遗忘的计时器等
- **客户端安全性：**代码在用户的计算机上执行，在某些情况下可能被用于恶意目的。
- **不同浏览器的支持程度不同** 。 JavaScript有时会被不同的浏览器区别对待。虽然服务器端脚本总是会产生相同的输出，但客户端脚本可能有点不可预测。
- **不适合开发大型程序：**很难模块化；没有如何将代码分布在多个文件的规范；允许同名函数的重复定义，后面的定义可以覆盖前面的定义，很不利于模块化加载。
- **全局变量难以控制：**Javascript的全局变量在所有模块中都是可见的；任何一个函数内部都可以通过var生成全局变量。

### 





